/*
 * Dynatrace Environment API
 * Documentation of the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/xc03k3c).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.dynatrace.apis.envv1.api;

import com.dynatrace.apis.envv1.ApiClient;
import com.dynatrace.apis.envv1.ApiException;
import com.dynatrace.apis.envv1.ApiResponse;
import com.dynatrace.apis.envv1.Pair;

import com.dynatrace.apis.envv1.model.AnonymizationIdResult;
import com.dynatrace.apis.envv1.model.AnonymizationProgressResult;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:03.911513100+01:00[Europe/Brussels]")
public class AnonymizationApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public AnonymizationApi() {
    this(new ApiClient());
  }

  public AnonymizationApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Creates user session anonymization job
   * The job anonymizes all user sessions in the specified timeframe by masking the specified fields.   To identify user sessions to be anonymized you can specify either userID, or IP address, or both. If you specify both the **OR** logic applies.   You can&#39;t undo the anonymization.
   * @param startTimestamp The start timestamp of the user session to anonymize, in UTC milliseconds.   If not set the earliest available time is used. (optional, default to 0)
   * @param endTimestamp The end timestamp of the user session to anonymize, in UTC milliseconds.   If not set the current time is used. (optional, default to 0)
   * @param userIds The UserID of the user to anonymize.    You can specify several IDs, in the following format: &#x60;userIds&#x3D;user1&amp;userIds&#x3D;user2&#x60;. (optional
   * @param ips The IP address of the user to anonymize. All user sessions from this IP will be anonymized.   You can specify several IPs, in the following format: &#x60;ips&#x3D;ip1&amp;ips&#x3D;ip2&#x60;. (optional
   * @param additionalField A list of fields to be anonymized.   You can specify several fields, in the following format: &#x60;additionalField&#x3D;field1&amp;additionalField&#x3D;field2&#x60;. (optional
   * @return AnonymizationIdResult
   * @throws ApiException if fails to make API call
   */
  public AnonymizationIdResult anonymize(Long startTimestamp, Long endTimestamp, List<String> userIds, List<String> ips, List<String> additionalField) throws ApiException {
    ApiResponse<AnonymizationIdResult> localVarResponse = anonymizeWithHttpInfo(startTimestamp, endTimestamp, userIds, ips, additionalField);
    return localVarResponse.getData();
  }

  /**
   * Creates user session anonymization job
   * The job anonymizes all user sessions in the specified timeframe by masking the specified fields.   To identify user sessions to be anonymized you can specify either userID, or IP address, or both. If you specify both the **OR** logic applies.   You can&#39;t undo the anonymization.
   * @param startTimestamp The start timestamp of the user session to anonymize, in UTC milliseconds.   If not set the earliest available time is used. (optional, default to 0)
   * @param endTimestamp The end timestamp of the user session to anonymize, in UTC milliseconds.   If not set the current time is used. (optional, default to 0)
   * @param userIds The UserID of the user to anonymize.    You can specify several IDs, in the following format: &#x60;userIds&#x3D;user1&amp;userIds&#x3D;user2&#x60;. (optional
   * @param ips The IP address of the user to anonymize. All user sessions from this IP will be anonymized.   You can specify several IPs, in the following format: &#x60;ips&#x3D;ip1&amp;ips&#x3D;ip2&#x60;. (optional
   * @param additionalField A list of fields to be anonymized.   You can specify several fields, in the following format: &#x60;additionalField&#x3D;field1&amp;additionalField&#x3D;field2&#x60;. (optional
   * @return ApiResponse&lt;AnonymizationIdResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AnonymizationIdResult> anonymizeWithHttpInfo(Long startTimestamp, Long endTimestamp, List<String> userIds, List<String> ips, List<String> additionalField) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = anonymizeRequestBuilder(startTimestamp, endTimestamp, userIds, ips, additionalField);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("anonymize", localVarResponse);
        }
        return new ApiResponse<AnonymizationIdResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<AnonymizationIdResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder anonymizeRequestBuilder(Long startTimestamp, Long endTimestamp, List<String> userIds, List<String> ips, List<String> additionalField) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/anonymize/anonymizationJobs";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("startTimestamp", startTimestamp));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("endTimestamp", endTimestamp));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "userIds", userIds));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "ips", ips));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "additionalField", additionalField));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Shows the progress of the specified anonymization job
   * 
   * @param requestId The ID of the required anonymization job. (required)
   * @return AnonymizationProgressResult
   * @throws ApiException if fails to make API call
   */
  public AnonymizationProgressResult getStatus(String requestId) throws ApiException {
    ApiResponse<AnonymizationProgressResult> localVarResponse = getStatusWithHttpInfo(requestId);
    return localVarResponse.getData();
  }

  /**
   * Shows the progress of the specified anonymization job
   * 
   * @param requestId The ID of the required anonymization job. (required)
   * @return ApiResponse&lt;AnonymizationProgressResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AnonymizationProgressResult> getStatusWithHttpInfo(String requestId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getStatusRequestBuilder(requestId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getStatus", localVarResponse);
        }
        return new ApiResponse<AnonymizationProgressResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<AnonymizationProgressResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getStatusRequestBuilder(String requestId) throws ApiException {
    // verify the required parameter 'requestId' is set
    if (requestId == null) {
      throw new ApiException(400, "Missing the required parameter 'requestId' when calling getStatus");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/anonymize/anonymizationJobs/{requestId}"
        .replace("{requestId}", ApiClient.urlEncode(requestId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
