/*
 * Dynatrace Environment API
 * Documentation of the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/xc03k3c).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.dynatrace.apis.envv1.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * List of metric&#39;s datapoints, as well as their parameters.
 */
@ApiModel(description = "List of metric's datapoints, as well as their parameters.")
@JsonPropertyOrder({
  TimeseriesDataPointQueryResult.JSON_PROPERTY_DATA_POINTS,
  TimeseriesDataPointQueryResult.JSON_PROPERTY_TIMESERIES_ID,
  TimeseriesDataPointQueryResult.JSON_PROPERTY_UNIT,
  TimeseriesDataPointQueryResult.JSON_PROPERTY_RESOLUTION_IN_MILLIS_U_T_C,
  TimeseriesDataPointQueryResult.JSON_PROPERTY_AGGREGATION_TYPE,
  TimeseriesDataPointQueryResult.JSON_PROPERTY_ENTITIES
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:03.911513100+01:00[Europe/Brussels]")
public class TimeseriesDataPointQueryResult {
  public static final String JSON_PROPERTY_DATA_POINTS = "dataPoints";
  private Map<String, List<List<Float>>> dataPoints = null;

  public static final String JSON_PROPERTY_TIMESERIES_ID = "timeseriesId";
  private String timeseriesId;

  /**
   * The unit of data points.
   */
  public enum UnitEnum {
    BILLION_BILCOUNT_("Billion (bilcount)"),
    
    BIT_BIT_("Bit (bit)"),
    
    BITPERHOUR_BIT_H_("BitPerHour (bit/h)"),
    
    BITPERMINUTE_BIT_MIN_("BitPerMinute (bit/min)"),
    
    BITPERSECOND_BIT_S_("BitPerSecond (bit/s)"),
    
    BYTE_B_("Byte (B)"),
    
    BYTEPERHOUR_B_H_("BytePerHour (B/h)"),
    
    BYTEPERMINUTE_B_MIN_("BytePerMinute (B/min)"),
    
    BYTEPERSECOND_B_S_("BytePerSecond (B/s)"),
    
    CORES("Cores"),
    
    COUNT_COUNT_("Count (count)"),
    
    DAY_DS_("Day (ds)"),
    
    DECIBELMILLIWATT_DBM_("DecibelMilliWatt (dBm)"),
    
    G("G"),
    
    GIBIBYTE_GIB_("GibiByte (GiB)"),
    
    GIGABYTE_GB_("GigaByte (GB)"),
    
    HOUR_HS_("Hour (hs)"),
    
    KIBIBYTE_KIB_("KibiByte (KiB)"),
    
    KIBIBYTEPERHOUR_KIB_H_("KibiBytePerHour (KiB/h)"),
    
    KIBIBYTEPERMINUTE_KIB_MIN_("KibiBytePerMinute (KiB/min)"),
    
    KIBIBYTEPERSECOND_KIB_S_("KibiBytePerSecond (KiB/s)"),
    
    KILOBYTE_KB_("KiloByte (kB)"),
    
    KILOBYTEPERHOUR_KB_H_("KiloBytePerHour (kB/h)"),
    
    KILOBYTEPERMINUTE_KB_MIN_("KiloBytePerMinute (kB/min)"),
    
    KILOBYTEPERSECOND_KB_S_("KiloBytePerSecond (kB/s)"),
    
    M("M"),
    
    MSU("MSU"),
    
    MEBIBYTE_MIB_("MebiByte (MiB)"),
    
    MEBIBYTEPERHOUR_MIB_H_("MebiBytePerHour (MiB/h)"),
    
    MEBIBYTEPERMINUTE_MIB_MIN_("MebiBytePerMinute (MiB/min)"),
    
    MEBIBYTEPERSECOND_MIB_S_("MebiBytePerSecond (MiB/s)"),
    
    MEGABYTE_MB_("MegaByte (MB)"),
    
    MEGABYTEPERHOUR_MB_H_("MegaBytePerHour (MB/h)"),
    
    MEGABYTEPERMINUTE_MB_MIN_("MegaBytePerMinute (MB/min)"),
    
    MEGABYTEPERSECOND_MB_S_("MegaBytePerSecond (MB/s)"),
    
    MICROSECOND_S_("MicroSecond (µs)"),
    
    MILLISECOND_MS_("MilliSecond (ms)"),
    
    MILLISECONDPERMINUTE_MS_MIN_("MilliSecondPerMinute (ms/min)"),
    
    MILLION_MILCOUNT_("Million (milcount)"),
    
    MINUTE_MINS_("Minute (mins)"),
    
    MONTH_MOS_("Month (mos)"),
    
    N_A("N/A"),
    
    NANOSECOND_NS_("NanoSecond (ns)"),
    
    NANOSECONDPERMINUTE_NS_MIN_("NanoSecondPerMinute (ns/min)"),
    
    PERHOUR_COUNT_H_("PerHour (count/h)"),
    
    PERMINUTE_COUNT_MIN_("PerMinute (count/min)"),
    
    PERSECOND_COUNT_S_("PerSecond (count/s)"),
    
    PERCENT_("Percent (%)"),
    
    PIXEL_PX_("Pixel (px)"),
    
    PROMILLE_("Promille (‰)"),
    
    RATIO("Ratio"),
    
    SECOND_S_("Second (s)"),
    
    STATE("State"),
    
    UNSPECIFIED("Unspecified"),
    
    WEEK_WS_("Week (ws)"),
    
    YEAR_YS_("Year (ys)"),
    
    K("k"),
    
    KM_H("km/h"),
    
    M_H("m/h"),
    
    M_S("m/s"),
    
    MCORES("mCores");

    private String value;

    UnitEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static UnitEnum fromValue(String value) {
      for (UnitEnum b : UnitEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_UNIT = "unit";
  private UnitEnum unit;

  public static final String JSON_PROPERTY_RESOLUTION_IN_MILLIS_U_T_C = "resolutionInMillisUTC";
  private Long resolutionInMillisUTC;

  /**
   * The type of data points aggregation.
   */
  public enum AggregationTypeEnum {
    AVG("AVG"),
    
    COUNT("COUNT"),
    
    MAX("MAX"),
    
    MEDIAN("MEDIAN"),
    
    MIN("MIN"),
    
    PERCENTILE("PERCENTILE"),
    
    SUM("SUM");

    private String value;

    AggregationTypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static AggregationTypeEnum fromValue(String value) {
      for (AggregationTypeEnum b : AggregationTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_AGGREGATION_TYPE = "aggregationType";
  private AggregationTypeEnum aggregationType;

  public static final String JSON_PROPERTY_ENTITIES = "entities";
  private Map<String, String> entities = null;

  public TimeseriesDataPointQueryResult() { 
  }

  public TimeseriesDataPointQueryResult dataPoints(Map<String, List<List<Float>>> dataPoints) {
    this.dataPoints = dataPoints;
    return this;
  }

  public TimeseriesDataPointQueryResult putDataPointsItem(String key, List<List<Float>> dataPointsItem) {
    if (this.dataPoints == null) {
      this.dataPoints = new HashMap<>();
    }
    this.dataPoints.put(key, dataPointsItem);
    return this;
  }

   /**
   * Data points of a metric.   A JSON object that maps the ID of the entity that delivered the data points and an array, which consists of arrays of the data point float values.   May contain more than one entity ID per record (for example, a host and its network interface). In such cases, entity IDs are separated by commas.   A datapoint contains a value and a timestamp, at which the value was recorded.    Dynatrace stores data in time slots. The **dataPoints** object shows the *starting* timestamp of the slot. If the **startTimestamp** or **endTimestamp** of your query lies inside of the data time slot, this time slot is included into response. Due to the fact that the timestamp of the first data point lies outside of the specified timeframe, you will see *earlier* timestamp than the specified **startTimestamp** in the first data point of the response.   There are three versions of data points:   * Numeric datapoint: Contains a numeric value.   * Enum datapoint: Contains an enum value, currently only for availability timeseries.   * Prediction datapoint: Similar to the numeric datapoint, but it contains a confidence interval, within which the future values are expected to be.
   * @return dataPoints
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Data points of a metric.   A JSON object that maps the ID of the entity that delivered the data points and an array, which consists of arrays of the data point float values.   May contain more than one entity ID per record (for example, a host and its network interface). In such cases, entity IDs are separated by commas.   A datapoint contains a value and a timestamp, at which the value was recorded.    Dynatrace stores data in time slots. The **dataPoints** object shows the *starting* timestamp of the slot. If the **startTimestamp** or **endTimestamp** of your query lies inside of the data time slot, this time slot is included into response. Due to the fact that the timestamp of the first data point lies outside of the specified timeframe, you will see *earlier* timestamp than the specified **startTimestamp** in the first data point of the response.   There are three versions of data points:   * Numeric datapoint: Contains a numeric value.   * Enum datapoint: Contains an enum value, currently only for availability timeseries.   * Prediction datapoint: Similar to the numeric datapoint, but it contains a confidence interval, within which the future values are expected to be.")
  @JsonProperty(JSON_PROPERTY_DATA_POINTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, List<List<Float>>> getDataPoints() {
    return dataPoints;
  }


  @JsonProperty(JSON_PROPERTY_DATA_POINTS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDataPoints(Map<String, List<List<Float>>> dataPoints) {
    this.dataPoints = dataPoints;
  }


  public TimeseriesDataPointQueryResult timeseriesId(String timeseriesId) {
    this.timeseriesId = timeseriesId;
    return this;
  }

   /**
   * The ID of the metric.
   * @return timeseriesId
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The ID of the metric.")
  @JsonProperty(JSON_PROPERTY_TIMESERIES_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getTimeseriesId() {
    return timeseriesId;
  }


  @JsonProperty(JSON_PROPERTY_TIMESERIES_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTimeseriesId(String timeseriesId) {
    this.timeseriesId = timeseriesId;
  }


  public TimeseriesDataPointQueryResult unit(UnitEnum unit) {
    this.unit = unit;
    return this;
  }

   /**
   * The unit of data points.
   * @return unit
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The unit of data points.")
  @JsonProperty(JSON_PROPERTY_UNIT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public UnitEnum getUnit() {
    return unit;
  }


  @JsonProperty(JSON_PROPERTY_UNIT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUnit(UnitEnum unit) {
    this.unit = unit;
  }


  public TimeseriesDataPointQueryResult resolutionInMillisUTC(Long resolutionInMillisUTC) {
    this.resolutionInMillisUTC = resolutionInMillisUTC;
    return this;
  }

   /**
   * The resolution of data points.
   * @return resolutionInMillisUTC
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The resolution of data points.")
  @JsonProperty(JSON_PROPERTY_RESOLUTION_IN_MILLIS_U_T_C)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getResolutionInMillisUTC() {
    return resolutionInMillisUTC;
  }


  @JsonProperty(JSON_PROPERTY_RESOLUTION_IN_MILLIS_U_T_C)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setResolutionInMillisUTC(Long resolutionInMillisUTC) {
    this.resolutionInMillisUTC = resolutionInMillisUTC;
  }


  public TimeseriesDataPointQueryResult aggregationType(AggregationTypeEnum aggregationType) {
    this.aggregationType = aggregationType;
    return this;
  }

   /**
   * The type of data points aggregation.
   * @return aggregationType
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The type of data points aggregation.")
  @JsonProperty(JSON_PROPERTY_AGGREGATION_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public AggregationTypeEnum getAggregationType() {
    return aggregationType;
  }


  @JsonProperty(JSON_PROPERTY_AGGREGATION_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAggregationType(AggregationTypeEnum aggregationType) {
    this.aggregationType = aggregationType;
  }


  public TimeseriesDataPointQueryResult entities(Map<String, String> entities) {
    this.entities = entities;
    return this;
  }

  public TimeseriesDataPointQueryResult putEntitiesItem(String key, String entitiesItem) {
    if (this.entities == null) {
      this.entities = new HashMap<>();
    }
    this.entities.put(key, entitiesItem);
    return this;
  }

   /**
   * The list of entities where the data points originate.  A JSON object that maps the entity ID in Dynatrace and the actual name of the entity.
   * @return entities
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The list of entities where the data points originate.  A JSON object that maps the entity ID in Dynatrace and the actual name of the entity.")
  @JsonProperty(JSON_PROPERTY_ENTITIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, String> getEntities() {
    return entities;
  }


  @JsonProperty(JSON_PROPERTY_ENTITIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEntities(Map<String, String> entities) {
    this.entities = entities;
  }


  /**
   * Return true if this TimeseriesDataPointQueryResult object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TimeseriesDataPointQueryResult timeseriesDataPointQueryResult = (TimeseriesDataPointQueryResult) o;
    return Objects.equals(this.dataPoints, timeseriesDataPointQueryResult.dataPoints) &&
        Objects.equals(this.timeseriesId, timeseriesDataPointQueryResult.timeseriesId) &&
        Objects.equals(this.unit, timeseriesDataPointQueryResult.unit) &&
        Objects.equals(this.resolutionInMillisUTC, timeseriesDataPointQueryResult.resolutionInMillisUTC) &&
        Objects.equals(this.aggregationType, timeseriesDataPointQueryResult.aggregationType) &&
        Objects.equals(this.entities, timeseriesDataPointQueryResult.entities);
  }

  @Override
  public int hashCode() {
    return Objects.hash(dataPoints, timeseriesId, unit, resolutionInMillisUTC, aggregationType, entities);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TimeseriesDataPointQueryResult {\n");
    sb.append("    dataPoints: ").append(toIndentedString(dataPoints)).append("\n");
    sb.append("    timeseriesId: ").append(toIndentedString(timeseriesId)).append("\n");
    sb.append("    unit: ").append(toIndentedString(unit)).append("\n");
    sb.append("    resolutionInMillisUTC: ").append(toIndentedString(resolutionInMillisUTC)).append("\n");
    sb.append("    aggregationType: ").append(toIndentedString(aggregationType)).append("\n");
    sb.append("    entities: ").append(toIndentedString(entities)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

