/*
 * Dynatrace Environment API
 * Documentation of the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/xc03k3c).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.dynatrace.apis.envv1.api;

import com.dynatrace.apis.envv1.ApiClient;
import com.dynatrace.apis.envv1.ApiException;
import com.dynatrace.apis.envv1.ApiResponse;
import com.dynatrace.apis.envv1.Pair;

import java.util.Set;
import com.dynatrace.apis.envv1.model.TimeseriesDefinition;
import com.dynatrace.apis.envv1.model.TimeseriesQueryMessage;
import com.dynatrace.apis.envv1.model.TimeseriesQueryResult;
import com.dynatrace.apis.envv1.model.TimeseriesQueryResultWrapper;
import com.dynatrace.apis.envv1.model.TimeseriesRegistrationMessage;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:03.911513100+01:00[Europe/Brussels]")
public class TimeseriesApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public TimeseriesApi() {
    this(new ApiClient());
  }

  public TimeseriesApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Creates a new custom metric
   * 
   * @param timeseriesIdentifier The ID for the new metric. It must start with the &#x60;custom:&#x60; prefix.   You can use alphanumeric characters and the following punctuation marks: periods (&#x60;.&#x60;), hyphens (&#x60;-&#x60;), and commas (&#x60;,&#x60;). A number cannot follow a punctuation mark.   If you use the ID of an existing metric the respective parameters will be updated.   The length of ID is limited to **256 characters**. (required)
   * @param timeseriesRegistrationMessage The JSON body of the request. Contains parameters of the new custom metric. (optional)
   * @return TimeseriesDefinition
   * @throws ApiException if fails to make API call
   */
  public TimeseriesDefinition createCustomTimeseries(String timeseriesIdentifier, TimeseriesRegistrationMessage timeseriesRegistrationMessage) throws ApiException {
    ApiResponse<TimeseriesDefinition> localVarResponse = createCustomTimeseriesWithHttpInfo(timeseriesIdentifier, timeseriesRegistrationMessage);
    return localVarResponse.getData();
  }

  /**
   * Creates a new custom metric
   * 
   * @param timeseriesIdentifier The ID for the new metric. It must start with the &#x60;custom:&#x60; prefix.   You can use alphanumeric characters and the following punctuation marks: periods (&#x60;.&#x60;), hyphens (&#x60;-&#x60;), and commas (&#x60;,&#x60;). A number cannot follow a punctuation mark.   If you use the ID of an existing metric the respective parameters will be updated.   The length of ID is limited to **256 characters**. (required)
   * @param timeseriesRegistrationMessage The JSON body of the request. Contains parameters of the new custom metric. (optional)
   * @return ApiResponse&lt;TimeseriesDefinition&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TimeseriesDefinition> createCustomTimeseriesWithHttpInfo(String timeseriesIdentifier, TimeseriesRegistrationMessage timeseriesRegistrationMessage) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createCustomTimeseriesRequestBuilder(timeseriesIdentifier, timeseriesRegistrationMessage);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createCustomTimeseries", localVarResponse);
        }
        return new ApiResponse<TimeseriesDefinition>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<TimeseriesDefinition>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createCustomTimeseriesRequestBuilder(String timeseriesIdentifier, TimeseriesRegistrationMessage timeseriesRegistrationMessage) throws ApiException {
    // verify the required parameter 'timeseriesIdentifier' is set
    if (timeseriesIdentifier == null) {
      throw new ApiException(400, "Missing the required parameter 'timeseriesIdentifier' when calling createCustomTimeseries");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/timeseries/{timeseriesIdentifier}"
        .replace("{timeseriesIdentifier}", ApiClient.urlEncode(timeseriesIdentifier.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(timeseriesRegistrationMessage);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Deletes the specified custom metric
   * 
   * @param timeseriesIdentifier The ID of the metric to delete. (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteCustomTimeseries(String timeseriesIdentifier) throws ApiException {
    deleteCustomTimeseriesWithHttpInfo(timeseriesIdentifier);
  }

  /**
   * Deletes the specified custom metric
   * 
   * @param timeseriesIdentifier The ID of the metric to delete. (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> deleteCustomTimeseriesWithHttpInfo(String timeseriesIdentifier) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = deleteCustomTimeseriesRequestBuilder(timeseriesIdentifier);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("deleteCustomTimeseries", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder deleteCustomTimeseriesRequestBuilder(String timeseriesIdentifier) throws ApiException {
    // verify the required parameter 'timeseriesIdentifier' is set
    if (timeseriesIdentifier == null) {
      throw new ApiException(400, "Missing the required parameter 'timeseriesIdentifier' when calling deleteCustomTimeseries");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/timeseries/{timeseriesIdentifier}"
        .replace("{timeseriesIdentifier}", ApiClient.urlEncode(timeseriesIdentifier.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists all metric definitions, with the parameters of each metric
   * You can specify filtering parameters to return only matched metrics. If no parameters are specified, the call will list all the defined metrics.
   * @param source The type of the metric, such as BUILTIN or CUSTOM. (optional)
   * @param detailedSource The feature where metrics originates, such as Synthetic or RUM. (optional)
   * @return List&lt;TimeseriesDefinition&gt;
   * @throws ApiException if fails to make API call
   */
  public List<TimeseriesDefinition> getAllTimeseriesDefinitions(String source, String detailedSource) throws ApiException {
    ApiResponse<List<TimeseriesDefinition>> localVarResponse = getAllTimeseriesDefinitionsWithHttpInfo(source, detailedSource);
    return localVarResponse.getData();
  }

  /**
   * Lists all metric definitions, with the parameters of each metric
   * You can specify filtering parameters to return only matched metrics. If no parameters are specified, the call will list all the defined metrics.
   * @param source The type of the metric, such as BUILTIN or CUSTOM. (optional)
   * @param detailedSource The feature where metrics originates, such as Synthetic or RUM. (optional)
   * @return ApiResponse&lt;List&lt;TimeseriesDefinition&gt;&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<List<TimeseriesDefinition>> getAllTimeseriesDefinitionsWithHttpInfo(String source, String detailedSource) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getAllTimeseriesDefinitionsRequestBuilder(source, detailedSource);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getAllTimeseriesDefinitions", localVarResponse);
        }
        return new ApiResponse<List<TimeseriesDefinition>>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<List<TimeseriesDefinition>>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getAllTimeseriesDefinitionsRequestBuilder(String source, String detailedSource) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/timeseries";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("source", source));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("detailedSource", detailedSource));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists all available metric data points, matching the specified parameters
   * Provides advanced filtering possibilities, comparing to the &#x60;GET /timeseries/{metricIdentifier}&#x60; request.
   * @param timeseriesIdentifier The case-sensitive ID of the timeseries from which you want to read parameters and data points. (required)
   * @param timeseriesQueryMessage The JSON body of the request, containing parameters to identify the required data points. (optional)
   * @return TimeseriesQueryResultWrapper
   * @throws ApiException if fails to make API call
   */
  public TimeseriesQueryResultWrapper readTimeseriesComplex(String timeseriesIdentifier, TimeseriesQueryMessage timeseriesQueryMessage) throws ApiException {
    ApiResponse<TimeseriesQueryResultWrapper> localVarResponse = readTimeseriesComplexWithHttpInfo(timeseriesIdentifier, timeseriesQueryMessage);
    return localVarResponse.getData();
  }

  /**
   * Lists all available metric data points, matching the specified parameters
   * Provides advanced filtering possibilities, comparing to the &#x60;GET /timeseries/{metricIdentifier}&#x60; request.
   * @param timeseriesIdentifier The case-sensitive ID of the timeseries from which you want to read parameters and data points. (required)
   * @param timeseriesQueryMessage The JSON body of the request, containing parameters to identify the required data points. (optional)
   * @return ApiResponse&lt;TimeseriesQueryResultWrapper&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TimeseriesQueryResultWrapper> readTimeseriesComplexWithHttpInfo(String timeseriesIdentifier, TimeseriesQueryMessage timeseriesQueryMessage) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = readTimeseriesComplexRequestBuilder(timeseriesIdentifier, timeseriesQueryMessage);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("readTimeseriesComplex", localVarResponse);
        }
        return new ApiResponse<TimeseriesQueryResultWrapper>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<TimeseriesQueryResultWrapper>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder readTimeseriesComplexRequestBuilder(String timeseriesIdentifier, TimeseriesQueryMessage timeseriesQueryMessage) throws ApiException {
    // verify the required parameter 'timeseriesIdentifier' is set
    if (timeseriesIdentifier == null) {
      throw new ApiException(400, "Missing the required parameter 'timeseriesIdentifier' when calling readTimeseriesComplex");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/timeseries/{timeseriesIdentifier}"
        .replace("{timeseriesIdentifier}", ApiClient.urlEncode(timeseriesIdentifier.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(timeseriesQueryMessage);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets the parameters of the specified metric and, optionally, its data points
   * To obtain data points, set **includeData** to &#x60;true&#x60;.   You can obtain either data points or the scalar result of the specified timeseries, depending on the **queryMode**.   To obtain data points, you must specify the timeframe, either as **relativeTime** or as a combination of **startTimestamp** and **endTimestamp**.   You must also provide the **aggregationType**, supported by the metric.
   * @param timeseriesIdentifier The case-sensitive ID of the timeseries, from which you want to read parameters and data points. (required)
   * @param includeData The flag to include data points in the response. Set to &#x60;true&#x60; to obtain data points. You must also specify the timeframe and aggregation type.   Defaults to &#x60;false&#x60;, meaning data points are not included. (optional)
   * @param aggregationType The aggregation type for the resulting data points.   If the requested metric doesn&#39;t support the specified aggregation, the request will result in an error. (optional)
   * @param startTimestamp The start timestamp of the requested timeframe, in UTC milliseconds. (optional)
   * @param endTimestamp The end timestamp of the requested timeframe, in milliseconds (UTC).   If later than the current time, Dynatrace automatically uses the current time instead.   The timeframe must not exceed 6 months. (optional)
   * @param predict The flag to predict future data points. (optional)
   * @param relativeTime The relative timeframe, back from the current time. (optional)
   * @param queryMode The type of result that the call should return. Valid result modes are:   &#x60;series&#x60;: returns all the data points of the timeseries in specified timeframe.  &#x60;total&#x60;: returns one scalar value for the specified timeframe.   By default, the &#x60;series&#x60; mode is used. (optional)
   * @param entity Filters requested data points by the entity that should deliver them. Allowed values are Dynatrace entity IDs.   You can specify several entities in the following format: &#x60;entity&#x3D;entity1&amp;entity&#x3D;entity2&#x60;. The entity has to match at least one of the specified IDs.   If the selected entity doesn&#39;t support the requested timeseries, the request will result in an error. (optional
   * @param tag Filters requested data points by entity which should deliver them. Only data from entities with the specified tag is delivered.   You can specify several tags in the following format: &#x60;tag&#x3D;tag1&amp;tag&#x3D;tag2&#x60;. The entity has to match **all** the specified tags.   In case of key-value tags, such as imported AWS or CloudFoundry tags use the &#x60;key:value&#x60; format. If there&#39;s also a context, use the &#x60;[context]key:value&#x60; format. (optional
   * @param percentile Specifies which percentile of the selected response time metric should be delivered.  Applicable only to the &#x60;PERCENTILE&#x60; aggregation type.   Valid values for percentile are between 1 and 99.   Keep in mind that percentile export is possible only for response-time-based metrics such as application and service response times. (optional)
   * @param includeParentIds If set to true the result exposes dimension mappings between parent entities and their children.  For instance: SERVICE-0000000000000001, SERVICE_METHOD-0000000000000001 (optional)
   * @param considerMaintenanceWindowsForAvailability Exclude (&#x60;true&#x60;) or include (&#x60;false&#x60;) data points from any [maintenance window](https://dt-url.net/b2123rg0), defined in your environment. (optional)
   * @return TimeseriesQueryResult
   * @throws ApiException if fails to make API call
   */
  public TimeseriesQueryResult readTimeseriesData(String timeseriesIdentifier, Boolean includeData, String aggregationType, Long startTimestamp, Long endTimestamp, Boolean predict, String relativeTime, String queryMode, Set<String> entity, Set<String> tag, Integer percentile, Boolean includeParentIds, Boolean considerMaintenanceWindowsForAvailability) throws ApiException {
    ApiResponse<TimeseriesQueryResult> localVarResponse = readTimeseriesDataWithHttpInfo(timeseriesIdentifier, includeData, aggregationType, startTimestamp, endTimestamp, predict, relativeTime, queryMode, entity, tag, percentile, includeParentIds, considerMaintenanceWindowsForAvailability);
    return localVarResponse.getData();
  }

  /**
   * Gets the parameters of the specified metric and, optionally, its data points
   * To obtain data points, set **includeData** to &#x60;true&#x60;.   You can obtain either data points or the scalar result of the specified timeseries, depending on the **queryMode**.   To obtain data points, you must specify the timeframe, either as **relativeTime** or as a combination of **startTimestamp** and **endTimestamp**.   You must also provide the **aggregationType**, supported by the metric.
   * @param timeseriesIdentifier The case-sensitive ID of the timeseries, from which you want to read parameters and data points. (required)
   * @param includeData The flag to include data points in the response. Set to &#x60;true&#x60; to obtain data points. You must also specify the timeframe and aggregation type.   Defaults to &#x60;false&#x60;, meaning data points are not included. (optional)
   * @param aggregationType The aggregation type for the resulting data points.   If the requested metric doesn&#39;t support the specified aggregation, the request will result in an error. (optional)
   * @param startTimestamp The start timestamp of the requested timeframe, in UTC milliseconds. (optional)
   * @param endTimestamp The end timestamp of the requested timeframe, in milliseconds (UTC).   If later than the current time, Dynatrace automatically uses the current time instead.   The timeframe must not exceed 6 months. (optional)
   * @param predict The flag to predict future data points. (optional)
   * @param relativeTime The relative timeframe, back from the current time. (optional)
   * @param queryMode The type of result that the call should return. Valid result modes are:   &#x60;series&#x60;: returns all the data points of the timeseries in specified timeframe.  &#x60;total&#x60;: returns one scalar value for the specified timeframe.   By default, the &#x60;series&#x60; mode is used. (optional)
   * @param entity Filters requested data points by the entity that should deliver them. Allowed values are Dynatrace entity IDs.   You can specify several entities in the following format: &#x60;entity&#x3D;entity1&amp;entity&#x3D;entity2&#x60;. The entity has to match at least one of the specified IDs.   If the selected entity doesn&#39;t support the requested timeseries, the request will result in an error. (optional
   * @param tag Filters requested data points by entity which should deliver them. Only data from entities with the specified tag is delivered.   You can specify several tags in the following format: &#x60;tag&#x3D;tag1&amp;tag&#x3D;tag2&#x60;. The entity has to match **all** the specified tags.   In case of key-value tags, such as imported AWS or CloudFoundry tags use the &#x60;key:value&#x60; format. If there&#39;s also a context, use the &#x60;[context]key:value&#x60; format. (optional
   * @param percentile Specifies which percentile of the selected response time metric should be delivered.  Applicable only to the &#x60;PERCENTILE&#x60; aggregation type.   Valid values for percentile are between 1 and 99.   Keep in mind that percentile export is possible only for response-time-based metrics such as application and service response times. (optional)
   * @param includeParentIds If set to true the result exposes dimension mappings between parent entities and their children.  For instance: SERVICE-0000000000000001, SERVICE_METHOD-0000000000000001 (optional)
   * @param considerMaintenanceWindowsForAvailability Exclude (&#x60;true&#x60;) or include (&#x60;false&#x60;) data points from any [maintenance window](https://dt-url.net/b2123rg0), defined in your environment. (optional)
   * @return ApiResponse&lt;TimeseriesQueryResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<TimeseriesQueryResult> readTimeseriesDataWithHttpInfo(String timeseriesIdentifier, Boolean includeData, String aggregationType, Long startTimestamp, Long endTimestamp, Boolean predict, String relativeTime, String queryMode, Set<String> entity, Set<String> tag, Integer percentile, Boolean includeParentIds, Boolean considerMaintenanceWindowsForAvailability) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = readTimeseriesDataRequestBuilder(timeseriesIdentifier, includeData, aggregationType, startTimestamp, endTimestamp, predict, relativeTime, queryMode, entity, tag, percentile, includeParentIds, considerMaintenanceWindowsForAvailability);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("readTimeseriesData", localVarResponse);
        }
        return new ApiResponse<TimeseriesQueryResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<TimeseriesQueryResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder readTimeseriesDataRequestBuilder(String timeseriesIdentifier, Boolean includeData, String aggregationType, Long startTimestamp, Long endTimestamp, Boolean predict, String relativeTime, String queryMode, Set<String> entity, Set<String> tag, Integer percentile, Boolean includeParentIds, Boolean considerMaintenanceWindowsForAvailability) throws ApiException {
    // verify the required parameter 'timeseriesIdentifier' is set
    if (timeseriesIdentifier == null) {
      throw new ApiException(400, "Missing the required parameter 'timeseriesIdentifier' when calling readTimeseriesData");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/timeseries/{timeseriesIdentifier}"
        .replace("{timeseriesIdentifier}", ApiClient.urlEncode(timeseriesIdentifier.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("includeData", includeData));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("aggregationType", aggregationType));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("startTimestamp", startTimestamp));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("endTimestamp", endTimestamp));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("predict", predict));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("relativeTime", relativeTime));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("queryMode", queryMode));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "entity", entity));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "tag", tag));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("percentile", percentile));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("includeParentIds", includeParentIds));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("considerMaintenanceWindowsForAvailability", considerMaintenanceWindowsForAvailability));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
