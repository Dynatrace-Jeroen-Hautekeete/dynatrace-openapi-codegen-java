/*
 * Dynatrace Environment API
 * Documentation of the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/xc03k3c).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.dynatrace.apis.envv1.api;

import com.dynatrace.apis.envv1.ApiClient;
import com.dynatrace.apis.envv1.ApiException;
import com.dynatrace.apis.envv1.ApiResponse;
import com.dynatrace.apis.envv1.Pair;

import com.dynatrace.apis.envv1.model.EventCreation;
import com.dynatrace.apis.envv1.model.EventQueryResult;
import com.dynatrace.apis.envv1.model.EventRestEntry;
import com.dynatrace.apis.envv1.model.EventStoreResult;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:03.911513100+01:00[Europe/Brussels]")
public class EventsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public EventsApi() {
    this(new ApiClient());
  }

  public EventsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Gets the parameters of the specified event
   * 
   * @param eventId The ID of the required event. (required)
   * @return EventRestEntry
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public EventRestEntry getEventById(String eventId) throws ApiException {
    ApiResponse<EventRestEntry> localVarResponse = getEventByIdWithHttpInfo(eventId);
    return localVarResponse.getData();
  }

  /**
   * Gets the parameters of the specified event
   * 
   * @param eventId The ID of the required event. (required)
   * @return ApiResponse&lt;EventRestEntry&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public ApiResponse<EventRestEntry> getEventByIdWithHttpInfo(String eventId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getEventByIdRequestBuilder(eventId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getEventById", localVarResponse);
        }
        return new ApiResponse<EventRestEntry>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventRestEntry>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getEventByIdRequestBuilder(String eventId) throws ApiException {
    // verify the required parameter 'eventId' is set
    if (eventId == null) {
      throw new ApiException(400, "Missing the required parameter 'eventId' when calling getEventById");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/events/{eventId}"
        .replace("{eventId}", ApiClient.urlEncode(eventId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Pushes custom events to one or more monitored entities
   * You can use this endpoint to:   * Push information-only events from third-party systems such as CI platforms (Jenkins, Bamboo, Electric Cloud, etc.) to provide additional information for Dynatrace automated root cause analysis. The time of event closure is already known and the event IDs are returned instantly. You can report these events for up to **30 days** into the past. The information-only event types are:  &#x60;CUSTOM_ANNOTATION&#x60;   &#x60;CUSTOM_CONFIGURATION&#x60;   &#x60;CUSTOM_DEPLOYMENT&#x60;   &#x60;CUSTOM_INFO&#x60;   &#x60;MARKED_FOR_TERMINATION&#x60;   * Push problem-opening events (for example, an error rate increase) to trigger the Dynatrace automated root cause analysis engine.  Correlation IDs are returned instead of event IDs. These events stay open until the specified timeout expires. To prevent expiration, you can refresh these events by sending the same payload again. You can report these events for up to **60 minutes** into the past. The problem-opening event types are (sorted by severity level, descending):  &#x60;AVAILABILITY_EVENT&#x60;   &#x60;ERROR_EVENT&#x60;   &#x60;PERFORMANCE_EVENT&#x60;   &#x60;RESOURCE_CONTENTION&#x60;   The actual set of event parameters depends on the type of your event. To find the parameters mapping, see [POST an event](https://dt-url.net/1v63r77) in Dynatrace Documentation.
   * @param eventCreation The JSON body of the request, containing parameters of the event. (optional)
   * @return EventStoreResult
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public EventStoreResult postEvent(EventCreation eventCreation) throws ApiException {
    ApiResponse<EventStoreResult> localVarResponse = postEventWithHttpInfo(eventCreation);
    return localVarResponse.getData();
  }

  /**
   * Pushes custom events to one or more monitored entities
   * You can use this endpoint to:   * Push information-only events from third-party systems such as CI platforms (Jenkins, Bamboo, Electric Cloud, etc.) to provide additional information for Dynatrace automated root cause analysis. The time of event closure is already known and the event IDs are returned instantly. You can report these events for up to **30 days** into the past. The information-only event types are:  &#x60;CUSTOM_ANNOTATION&#x60;   &#x60;CUSTOM_CONFIGURATION&#x60;   &#x60;CUSTOM_DEPLOYMENT&#x60;   &#x60;CUSTOM_INFO&#x60;   &#x60;MARKED_FOR_TERMINATION&#x60;   * Push problem-opening events (for example, an error rate increase) to trigger the Dynatrace automated root cause analysis engine.  Correlation IDs are returned instead of event IDs. These events stay open until the specified timeout expires. To prevent expiration, you can refresh these events by sending the same payload again. You can report these events for up to **60 minutes** into the past. The problem-opening event types are (sorted by severity level, descending):  &#x60;AVAILABILITY_EVENT&#x60;   &#x60;ERROR_EVENT&#x60;   &#x60;PERFORMANCE_EVENT&#x60;   &#x60;RESOURCE_CONTENTION&#x60;   The actual set of event parameters depends on the type of your event. To find the parameters mapping, see [POST an event](https://dt-url.net/1v63r77) in Dynatrace Documentation.
   * @param eventCreation The JSON body of the request, containing parameters of the event. (optional)
   * @return ApiResponse&lt;EventStoreResult&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public ApiResponse<EventStoreResult> postEventWithHttpInfo(EventCreation eventCreation) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = postEventRequestBuilder(eventCreation);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("postEvent", localVarResponse);
        }
        return new ApiResponse<EventStoreResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventStoreResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder postEventRequestBuilder(EventCreation eventCreation) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/events";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(eventCreation);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists all the events of your environment, along with their parameters
   * Because the possible number of events can be huge, the response is limited to 150 events. You can focus the output by specifying filtering parameters for the request.  An event is included in the response, if either start or end timestamp of the event is within the defined timeframe.
   * @param from Start timestamp of the query, in UTC milliseconds.    If not set, 30 days ago from now is used, unless **relativeTime** is set. (optional)
   * @param to End timestamp of the query, in UTC milliseconds.    If not set, the current timestamp is used, unless **relativeTime** is set.   The timeframe must not exceed 2 years. (optional)
   * @param relativeTime Relative timeframe, back from the current time. (optional)
   * @param eventType Filters the resulting set of events by the event type. (optional)
   * @param entityId Filters the resulting set of events to the events, related to the specified Dynatrace entity. (optional)
   * @param cursor The response is limited to 150 events, so if you want to receive more you can use the cursor to get the next 150. This parameter should be empty when querying for the first time.    The cursor key can then be found in the **nextCursor** field of the previous response.   When using the cursor string, it is not necessary to specify the additional parameters, as that info is already encoded within the cursor. (optional)
   * @return EventQueryResult
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public EventQueryResult queryEvents(Long from, Long to, String relativeTime, String eventType, String entityId, String cursor) throws ApiException {
    ApiResponse<EventQueryResult> localVarResponse = queryEventsWithHttpInfo(from, to, relativeTime, eventType, entityId, cursor);
    return localVarResponse.getData();
  }

  /**
   * Lists all the events of your environment, along with their parameters
   * Because the possible number of events can be huge, the response is limited to 150 events. You can focus the output by specifying filtering parameters for the request.  An event is included in the response, if either start or end timestamp of the event is within the defined timeframe.
   * @param from Start timestamp of the query, in UTC milliseconds.    If not set, 30 days ago from now is used, unless **relativeTime** is set. (optional)
   * @param to End timestamp of the query, in UTC milliseconds.    If not set, the current timestamp is used, unless **relativeTime** is set.   The timeframe must not exceed 2 years. (optional)
   * @param relativeTime Relative timeframe, back from the current time. (optional)
   * @param eventType Filters the resulting set of events by the event type. (optional)
   * @param entityId Filters the resulting set of events to the events, related to the specified Dynatrace entity. (optional)
   * @param cursor The response is limited to 150 events, so if you want to receive more you can use the cursor to get the next 150. This parameter should be empty when querying for the first time.    The cursor key can then be found in the **nextCursor** field of the previous response.   When using the cursor string, it is not necessary to specify the additional parameters, as that info is already encoded within the cursor. (optional)
   * @return ApiResponse&lt;EventQueryResult&gt;
   * @throws ApiException if fails to make API call
   * @deprecated
   */
  @Deprecated
  public ApiResponse<EventQueryResult> queryEventsWithHttpInfo(Long from, Long to, String relativeTime, String eventType, String entityId, String cursor) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = queryEventsRequestBuilder(from, to, relativeTime, eventType, entityId, cursor);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("queryEvents", localVarResponse);
        }
        return new ApiResponse<EventQueryResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventQueryResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder queryEventsRequestBuilder(Long from, Long to, String relativeTime, String eventType, String entityId, String cursor) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/events";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("from", from));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("to", to));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("relativeTime", relativeTime));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("eventType", eventType));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("entityId", entityId));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("cursor", cursor));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
