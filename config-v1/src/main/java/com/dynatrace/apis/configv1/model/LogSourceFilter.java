/*
 * Dynatrace Configuration API
 * Documentation of the Dynatrace Configuration API. To read about use-cases and examples, see [Dynatrace Documentation](https://dt-url.net/4u43kxw).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.dynatrace.apis.configv1.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.dynatrace.apis.configv1.model.PathDefinition;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * Configuration of the log filter for a custom log metric.   If several criteria are specified, the AND logic applies.
 */
@ApiModel(description = "Configuration of the log filter for a custom log metric.   If several criteria are specified, the AND logic applies.")
@JsonPropertyOrder({
  LogSourceFilter.JSON_PROPERTY_PATH_DEFINITIONS,
  LogSourceFilter.JSON_PROPERTY_SOURCE_ENTITIES,
  LogSourceFilter.JSON_PROPERTY_HOST_FILTERS,
  LogSourceFilter.JSON_PROPERTY_OS_TYPES
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:07:55.784964900+01:00[Europe/Brussels]")
public class LogSourceFilter {
  public static final String JSON_PROPERTY_PATH_DEFINITIONS = "pathDefinitions";
  private List<PathDefinition> pathDefinitions = null;

  public static final String JSON_PROPERTY_SOURCE_ENTITIES = "sourceEntities";
  private List<String> sourceEntities = null;

  public static final String JSON_PROPERTY_HOST_FILTERS = "hostFilters";
  private List<String> hostFilters = null;

  /**
   * Gets or Sets osTypes
   */
  public enum OsTypesEnum {
    AIX("AIX"),
    
    DARWIN("DARWIN"),
    
    HPUX("HPUX"),
    
    LINUX("LINUX"),
    
    SOLARIS("SOLARIS"),
    
    WINDOWS("WINDOWS"),
    
    ZOS("ZOS");

    private String value;

    OsTypesEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static OsTypesEnum fromValue(String value) {
      for (OsTypesEnum b : OsTypesEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_OS_TYPES = "osTypes";
  private List<OsTypesEnum> osTypes = null;

  public LogSourceFilter() { 
  }

  public LogSourceFilter pathDefinitions(List<PathDefinition> pathDefinitions) {
    this.pathDefinitions = pathDefinitions;
    return this;
  }

  public LogSourceFilter addPathDefinitionsItem(PathDefinition pathDefinitionsItem) {
    if (this.pathDefinitions == null) {
      this.pathDefinitions = new ArrayList<>();
    }
    this.pathDefinitions.add(pathDefinitionsItem);
    return this;
  }

   /**
   * A list of filtering criteria for log path.   If several criteria are specified, the OR logic applies.
   * @return pathDefinitions
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of filtering criteria for log path.   If several criteria are specified, the OR logic applies.")
  @JsonProperty(JSON_PROPERTY_PATH_DEFINITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<PathDefinition> getPathDefinitions() {
    return pathDefinitions;
  }


  @JsonProperty(JSON_PROPERTY_PATH_DEFINITIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPathDefinitions(List<PathDefinition> pathDefinitions) {
    this.pathDefinitions = pathDefinitions;
  }


  public LogSourceFilter sourceEntities(List<String> sourceEntities) {
    this.sourceEntities = sourceEntities;
    return this;
  }

  public LogSourceFilter addSourceEntitiesItem(String sourceEntitiesItem) {
    if (this.sourceEntities == null) {
      this.sourceEntities = new ArrayList<>();
    }
    this.sourceEntities.add(sourceEntitiesItem);
    return this;
  }

   /**
   * A list of Dynatrace entities, where the log can originate from. Specify Dynatrace entity IDs here.    Allowed types of entities are &#x60;PROCESS_GROUP&#x60; and &#x60;PROCESS_GROUP_INSTANCE&#x60;. You can&#39;t mix entity types.   If several entities are specified, the OR logic applies.   This field is mutually exclusive with the **osTypes** field.
   * @return sourceEntities
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of Dynatrace entities, where the log can originate from. Specify Dynatrace entity IDs here.    Allowed types of entities are `PROCESS_GROUP` and `PROCESS_GROUP_INSTANCE`. You can't mix entity types.   If several entities are specified, the OR logic applies.   This field is mutually exclusive with the **osTypes** field.")
  @JsonProperty(JSON_PROPERTY_SOURCE_ENTITIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getSourceEntities() {
    return sourceEntities;
  }


  @JsonProperty(JSON_PROPERTY_SOURCE_ENTITIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSourceEntities(List<String> sourceEntities) {
    this.sourceEntities = sourceEntities;
  }


  public LogSourceFilter hostFilters(List<String> hostFilters) {
    this.hostFilters = hostFilters;
    return this;
  }

  public LogSourceFilter addHostFiltersItem(String hostFiltersItem) {
    if (this.hostFilters == null) {
      this.hostFilters = new ArrayList<>();
    }
    this.hostFilters.add(hostFiltersItem);
    return this;
  }

   /**
   * A list of hosts, where the log can originate from. Specify Dynatrace entity IDs here.   If several hosts are specified, the OR logic applies.
   * @return hostFilters
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of hosts, where the log can originate from. Specify Dynatrace entity IDs here.   If several hosts are specified, the OR logic applies.")
  @JsonProperty(JSON_PROPERTY_HOST_FILTERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getHostFilters() {
    return hostFilters;
  }


  @JsonProperty(JSON_PROPERTY_HOST_FILTERS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setHostFilters(List<String> hostFilters) {
    this.hostFilters = hostFilters;
  }


  public LogSourceFilter osTypes(List<OsTypesEnum> osTypes) {
    this.osTypes = osTypes;
    return this;
  }

  public LogSourceFilter addOsTypesItem(OsTypesEnum osTypesItem) {
    if (this.osTypes == null) {
      this.osTypes = new ArrayList<>();
    }
    this.osTypes.add(osTypesItem);
    return this;
  }

   /**
   * A list of operating system types, where the log can originate from.   If set, **only OS logs** are included in the result.   If several OS are specified, the OR logic applies.   This field is mutually exclusive with the **sourceEntities** field.
   * @return osTypes
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A list of operating system types, where the log can originate from.   If set, **only OS logs** are included in the result.   If several OS are specified, the OR logic applies.   This field is mutually exclusive with the **sourceEntities** field.")
  @JsonProperty(JSON_PROPERTY_OS_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<OsTypesEnum> getOsTypes() {
    return osTypes;
  }


  @JsonProperty(JSON_PROPERTY_OS_TYPES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOsTypes(List<OsTypesEnum> osTypes) {
    this.osTypes = osTypes;
  }


  /**
   * Return true if this LogSourceFilter object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    LogSourceFilter logSourceFilter = (LogSourceFilter) o;
    return Objects.equals(this.pathDefinitions, logSourceFilter.pathDefinitions) &&
        Objects.equals(this.sourceEntities, logSourceFilter.sourceEntities) &&
        Objects.equals(this.hostFilters, logSourceFilter.hostFilters) &&
        Objects.equals(this.osTypes, logSourceFilter.osTypes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(pathDefinitions, sourceEntities, hostFilters, osTypes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class LogSourceFilter {\n");
    sb.append("    pathDefinitions: ").append(toIndentedString(pathDefinitions)).append("\n");
    sb.append("    sourceEntities: ").append(toIndentedString(sourceEntities)).append("\n");
    sb.append("    hostFilters: ").append(toIndentedString(hostFilters)).append("\n");
    sb.append("    osTypes: ").append(toIndentedString(osTypes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

