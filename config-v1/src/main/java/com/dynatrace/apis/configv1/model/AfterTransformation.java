/*
 * Dynatrace Configuration API
 * Documentation of the Dynatrace Configuration API. To read about use-cases and examples, see [Dynatrace Documentation](https://dt-url.net/4u43kxw).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.dynatrace.apis.configv1.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.dynatrace.apis.configv1.model.TransformationBase;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.dynatrace.apis.configv1.JSON;
/**
 * The transformation of the &#x60;AFTER&#x60; type.The transformation removes everything before the specified delimiter and keeps the value after it.
 */
@ApiModel(description = "The transformation of the `AFTER` type.The transformation removes everything before the specified delimiter and keeps the value after it.")
@JsonPropertyOrder({
  AfterTransformation.JSON_PROPERTY_DELIMITER
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:07:55.784964900+01:00[Europe/Brussels]")
@JsonIgnoreProperties(
  value = "type", // ignore manually set type, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the type to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type", visible = true)

public class AfterTransformation extends TransformationBase {
  public static final String JSON_PROPERTY_DELIMITER = "delimiter";
  private String delimiter;

  public AfterTransformation() { 
  }

  public AfterTransformation delimiter(String delimiter) {
    this.delimiter = delimiter;
    return this;
  }

   /**
   * The delimiter of the transformation. The transformation removes everything before this delimiter and keeps everything after it.     The delimiter itself is not kept.    If several delimiters appear in the initial value, only the first one is used.
   * @return delimiter
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The delimiter of the transformation. The transformation removes everything before this delimiter and keeps everything after it.     The delimiter itself is not kept.    If several delimiters appear in the initial value, only the first one is used.")
  @JsonProperty(JSON_PROPERTY_DELIMITER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getDelimiter() {
    return delimiter;
  }


  @JsonProperty(JSON_PROPERTY_DELIMITER)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setDelimiter(String delimiter) {
    this.delimiter = delimiter;
  }


  /**
   * Return true if this AfterTransformation object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    AfterTransformation afterTransformation = (AfterTransformation) o;
    return Objects.equals(this.delimiter, afterTransformation.delimiter) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(delimiter, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class AfterTransformation {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    delimiter: ").append(toIndentedString(delimiter)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

static {
  // Initialize and register the discriminator mappings.
  Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
  mappings.put("AfterTransformation", AfterTransformation.class);
  JSON.registerDiscriminator(AfterTransformation.class, "type", mappings);
}
}

