/*
 * Dynatrace Configuration API
 * Documentation of the Dynatrace Configuration API. To read about use-cases and examples, see [Dynatrace Documentation](https://dt-url.net/4u43kxw).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.dynatrace.apis.configv1.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.dynatrace.apis.configv1.model.MetricEventMonitoringStrategy;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonSubTypes;
import com.fasterxml.jackson.annotation.JsonTypeInfo;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


import com.dynatrace.apis.configv1.JSON;
/**
 * An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time.
 */
@ApiModel(description = "An auto-adaptive baseline strategy to detect anomalies within metrics that show a regular change over time, as the baseline is also updated automatically. An example is to detect an anomaly in the number of received network packets or within the number of user actions over time.")
@JsonPropertyOrder({
  MetricEventAutoAdaptiveBaselineMonitoringStrategy.JSON_PROPERTY_SAMPLES,
  MetricEventAutoAdaptiveBaselineMonitoringStrategy.JSON_PROPERTY_VIOLATING_SAMPLES,
  MetricEventAutoAdaptiveBaselineMonitoringStrategy.JSON_PROPERTY_DEALERTING_SAMPLES,
  MetricEventAutoAdaptiveBaselineMonitoringStrategy.JSON_PROPERTY_ALERT_CONDITION,
  MetricEventAutoAdaptiveBaselineMonitoringStrategy.JSON_PROPERTY_ALERTING_ON_MISSING_DATA,
  MetricEventAutoAdaptiveBaselineMonitoringStrategy.JSON_PROPERTY_NUMBER_OF_SIGNAL_FLUCTUATIONS
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:07:55.784964900+01:00[Europe/Brussels]")
@JsonIgnoreProperties(
  value = "type", // ignore manually set type, it will be automatically generated by Jackson during serialization
  allowSetters = true // allows the type to be set during deserialization
)
@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = "type", visible = true)

public class MetricEventAutoAdaptiveBaselineMonitoringStrategy extends MetricEventMonitoringStrategy {
  public static final String JSON_PROPERTY_SAMPLES = "samples";
  private Integer samples;

  public static final String JSON_PROPERTY_VIOLATING_SAMPLES = "violatingSamples";
  private Integer violatingSamples;

  public static final String JSON_PROPERTY_DEALERTING_SAMPLES = "dealertingSamples";
  private Integer dealertingSamples;

  /**
   * The condition for the **threshold** value check: above or below.
   */
  public enum AlertConditionEnum {
    ABOVE("ABOVE"),
    
    BELOW("BELOW");

    private String value;

    AlertConditionEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static AlertConditionEnum fromValue(String value) {
      for (AlertConditionEnum b : AlertConditionEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_ALERT_CONDITION = "alertCondition";
  private AlertConditionEnum alertCondition;

  public static final String JSON_PROPERTY_ALERTING_ON_MISSING_DATA = "alertingOnMissingData";
  private Boolean alertingOnMissingData;

  public static final String JSON_PROPERTY_NUMBER_OF_SIGNAL_FLUCTUATIONS = "numberOfSignalFluctuations";
  private Double numberOfSignalFluctuations;

  public MetricEventAutoAdaptiveBaselineMonitoringStrategy() { 
  }

  public MetricEventAutoAdaptiveBaselineMonitoringStrategy samples(Integer samples) {
    this.samples = samples;
    return this;
  }

   /**
   * The number of one-minute samples that form the sliding evaluation window.
   * minimum: 3
   * maximum: 60
   * @return samples
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The number of one-minute samples that form the sliding evaluation window.")
  @JsonProperty(JSON_PROPERTY_SAMPLES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Integer getSamples() {
    return samples;
  }


  @JsonProperty(JSON_PROPERTY_SAMPLES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSamples(Integer samples) {
    this.samples = samples;
  }


  public MetricEventAutoAdaptiveBaselineMonitoringStrategy violatingSamples(Integer violatingSamples) {
    this.violatingSamples = violatingSamples;
    return this;
  }

   /**
   * The number of one-minute samples within the evaluation window that must violate the threshold to trigger an event.
   * minimum: 1
   * @return violatingSamples
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The number of one-minute samples within the evaluation window that must violate the threshold to trigger an event.")
  @JsonProperty(JSON_PROPERTY_VIOLATING_SAMPLES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Integer getViolatingSamples() {
    return violatingSamples;
  }


  @JsonProperty(JSON_PROPERTY_VIOLATING_SAMPLES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setViolatingSamples(Integer violatingSamples) {
    this.violatingSamples = violatingSamples;
  }


  public MetricEventAutoAdaptiveBaselineMonitoringStrategy dealertingSamples(Integer dealertingSamples) {
    this.dealertingSamples = dealertingSamples;
    return this;
  }

   /**
   * The number of one-minute samples within the evaluation window that must go back to normal to close the event.
   * minimum: 3
   * @return dealertingSamples
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The number of one-minute samples within the evaluation window that must go back to normal to close the event.")
  @JsonProperty(JSON_PROPERTY_DEALERTING_SAMPLES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Integer getDealertingSamples() {
    return dealertingSamples;
  }


  @JsonProperty(JSON_PROPERTY_DEALERTING_SAMPLES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setDealertingSamples(Integer dealertingSamples) {
    this.dealertingSamples = dealertingSamples;
  }


  public MetricEventAutoAdaptiveBaselineMonitoringStrategy alertCondition(AlertConditionEnum alertCondition) {
    this.alertCondition = alertCondition;
    return this;
  }

   /**
   * The condition for the **threshold** value check: above or below.
   * @return alertCondition
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The condition for the **threshold** value check: above or below.")
  @JsonProperty(JSON_PROPERTY_ALERT_CONDITION)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public AlertConditionEnum getAlertCondition() {
    return alertCondition;
  }


  @JsonProperty(JSON_PROPERTY_ALERT_CONDITION)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAlertCondition(AlertConditionEnum alertCondition) {
    this.alertCondition = alertCondition;
  }


  public MetricEventAutoAdaptiveBaselineMonitoringStrategy alertingOnMissingData(Boolean alertingOnMissingData) {
    this.alertingOnMissingData = alertingOnMissingData;
    return this;
  }

   /**
   * If true, also one-minute samples without data are counted as violating samples.
   * @return alertingOnMissingData
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If true, also one-minute samples without data are counted as violating samples.")
  @JsonProperty(JSON_PROPERTY_ALERTING_ON_MISSING_DATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getAlertingOnMissingData() {
    return alertingOnMissingData;
  }


  @JsonProperty(JSON_PROPERTY_ALERTING_ON_MISSING_DATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAlertingOnMissingData(Boolean alertingOnMissingData) {
    this.alertingOnMissingData = alertingOnMissingData;
  }


  public MetricEventAutoAdaptiveBaselineMonitoringStrategy numberOfSignalFluctuations(Double numberOfSignalFluctuations) {
    this.numberOfSignalFluctuations = numberOfSignalFluctuations;
    return this;
  }

   /**
   * Defines the factor of how many signal fluctuations are valid. Values above the baseline plus the signal fluctuation times the number of tolerated signal fluctuations are alerted.
   * minimum: 0
   * maximum: 10
   * @return numberOfSignalFluctuations
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "Defines the factor of how many signal fluctuations are valid. Values above the baseline plus the signal fluctuation times the number of tolerated signal fluctuations are alerted.")
  @JsonProperty(JSON_PROPERTY_NUMBER_OF_SIGNAL_FLUCTUATIONS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Double getNumberOfSignalFluctuations() {
    return numberOfSignalFluctuations;
  }


  @JsonProperty(JSON_PROPERTY_NUMBER_OF_SIGNAL_FLUCTUATIONS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setNumberOfSignalFluctuations(Double numberOfSignalFluctuations) {
    this.numberOfSignalFluctuations = numberOfSignalFluctuations;
  }


  /**
   * Return true if this MetricEventAutoAdaptiveBaselineMonitoringStrategy object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MetricEventAutoAdaptiveBaselineMonitoringStrategy metricEventAutoAdaptiveBaselineMonitoringStrategy = (MetricEventAutoAdaptiveBaselineMonitoringStrategy) o;
    return Objects.equals(this.samples, metricEventAutoAdaptiveBaselineMonitoringStrategy.samples) &&
        Objects.equals(this.violatingSamples, metricEventAutoAdaptiveBaselineMonitoringStrategy.violatingSamples) &&
        Objects.equals(this.dealertingSamples, metricEventAutoAdaptiveBaselineMonitoringStrategy.dealertingSamples) &&
        Objects.equals(this.alertCondition, metricEventAutoAdaptiveBaselineMonitoringStrategy.alertCondition) &&
        Objects.equals(this.alertingOnMissingData, metricEventAutoAdaptiveBaselineMonitoringStrategy.alertingOnMissingData) &&
        Objects.equals(this.numberOfSignalFluctuations, metricEventAutoAdaptiveBaselineMonitoringStrategy.numberOfSignalFluctuations) &&
        super.equals(o);
  }

  @Override
  public int hashCode() {
    return Objects.hash(samples, violatingSamples, dealertingSamples, alertCondition, alertingOnMissingData, numberOfSignalFluctuations, super.hashCode());
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MetricEventAutoAdaptiveBaselineMonitoringStrategy {\n");
    sb.append("    ").append(toIndentedString(super.toString())).append("\n");
    sb.append("    samples: ").append(toIndentedString(samples)).append("\n");
    sb.append("    violatingSamples: ").append(toIndentedString(violatingSamples)).append("\n");
    sb.append("    dealertingSamples: ").append(toIndentedString(dealertingSamples)).append("\n");
    sb.append("    alertCondition: ").append(toIndentedString(alertCondition)).append("\n");
    sb.append("    alertingOnMissingData: ").append(toIndentedString(alertingOnMissingData)).append("\n");
    sb.append("    numberOfSignalFluctuations: ").append(toIndentedString(numberOfSignalFluctuations)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

static {
  // Initialize and register the discriminator mappings.
  Map<String, Class<?>> mappings = new HashMap<String, Class<?>>();
  mappings.put("MetricEventAutoAdaptiveBaselineMonitoringStrategy", MetricEventAutoAdaptiveBaselineMonitoringStrategy.class);
  JSON.registerDiscriminator(MetricEventAutoAdaptiveBaselineMonitoringStrategy.class, "type", mappings);
}
}

