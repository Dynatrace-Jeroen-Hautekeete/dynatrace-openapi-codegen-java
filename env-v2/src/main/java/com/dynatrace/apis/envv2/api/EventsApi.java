/*
 * Dynatrace Environment API
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.dynatrace.apis.envv2.api;

import com.dynatrace.apis.envv2.ApiClient;
import com.dynatrace.apis.envv2.ApiException;
import com.dynatrace.apis.envv2.ApiResponse;
import com.dynatrace.apis.envv2.Pair;

import com.dynatrace.apis.envv2.model.Event;
import com.dynatrace.apis.envv2.model.EventIngest;
import com.dynatrace.apis.envv2.model.EventIngestResults;
import com.dynatrace.apis.envv2.model.EventList;
import com.dynatrace.apis.envv2.model.EventPropertyDetail;
import com.dynatrace.apis.envv2.model.EventPropertyDetails;
import com.dynatrace.apis.envv2.model.EventType;
import com.dynatrace.apis.envv2.model.EventTypeList;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:06.080821500+01:00[Europe/Brussels]")
public class EventsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public EventsApi() {
    this(new ApiClient());
  }

  public EventsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Ingests a custom event
   * The ingestion of custom events consumes [Davis Data Units](https://dt-url.net/ddu) (DDUs) from the events pool.
   * @param eventIngest The JSON body of the request. Contains properties of the new event. (optional)
   * @return EventIngestResults
   * @throws ApiException if fails to make API call
   */
  public EventIngestResults createEvent(EventIngest eventIngest) throws ApiException {
    ApiResponse<EventIngestResults> localVarResponse = createEventWithHttpInfo(eventIngest);
    return localVarResponse.getData();
  }

  /**
   * Ingests a custom event
   * The ingestion of custom events consumes [Davis Data Units](https://dt-url.net/ddu) (DDUs) from the events pool.
   * @param eventIngest The JSON body of the request. Contains properties of the new event. (optional)
   * @return ApiResponse&lt;EventIngestResults&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<EventIngestResults> createEventWithHttpInfo(EventIngest eventIngest) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createEventRequestBuilder(eventIngest);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createEvent", localVarResponse);
        }
        return new ApiResponse<EventIngestResults>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventIngestResults>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createEventRequestBuilder(EventIngest eventIngest) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/events/ingest";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(eventIngest);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets the properties of an event
   * 
   * @param eventId The ID of the required event. (required)
   * @return Event
   * @throws ApiException if fails to make API call
   */
  public Event getEvent(String eventId) throws ApiException {
    ApiResponse<Event> localVarResponse = getEventWithHttpInfo(eventId);
    return localVarResponse.getData();
  }

  /**
   * Gets the properties of an event
   * 
   * @param eventId The ID of the required event. (required)
   * @return ApiResponse&lt;Event&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Event> getEventWithHttpInfo(String eventId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getEventRequestBuilder(eventId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getEvent", localVarResponse);
        }
        return new ApiResponse<Event>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Event>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getEventRequestBuilder(String eventId) throws ApiException {
    // verify the required parameter 'eventId' is set
    if (eventId == null) {
      throw new ApiException(400, "Missing the required parameter 'eventId' when calling getEvent");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/events/{eventId}"
        .replace("{eventId}", ApiClient.urlEncode(eventId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists all event properties
   * 
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The amount of event properties in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used. (optional)
   * @return EventPropertyDetails
   * @throws ApiException if fails to make API call
   */
  public EventPropertyDetails getEventProperties(String nextPageKey, Long pageSize) throws ApiException {
    ApiResponse<EventPropertyDetails> localVarResponse = getEventPropertiesWithHttpInfo(nextPageKey, pageSize);
    return localVarResponse.getData();
  }

  /**
   * Lists all event properties
   * 
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The amount of event properties in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used. (optional)
   * @return ApiResponse&lt;EventPropertyDetails&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<EventPropertyDetails> getEventPropertiesWithHttpInfo(String nextPageKey, Long pageSize) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getEventPropertiesRequestBuilder(nextPageKey, pageSize);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getEventProperties", localVarResponse);
        }
        return new ApiResponse<EventPropertyDetails>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventPropertyDetails>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getEventPropertiesRequestBuilder(String nextPageKey, Long pageSize) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/eventProperties";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nextPageKey", nextPageKey));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pageSize", pageSize));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets the details of an event property
   * 
   * @param propertyKey The event property key you&#39;re inquiring. (required)
   * @return EventPropertyDetail
   * @throws ApiException if fails to make API call
   */
  public EventPropertyDetail getEventProperty(String propertyKey) throws ApiException {
    ApiResponse<EventPropertyDetail> localVarResponse = getEventPropertyWithHttpInfo(propertyKey);
    return localVarResponse.getData();
  }

  /**
   * Gets the details of an event property
   * 
   * @param propertyKey The event property key you&#39;re inquiring. (required)
   * @return ApiResponse&lt;EventPropertyDetail&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<EventPropertyDetail> getEventPropertyWithHttpInfo(String propertyKey) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getEventPropertyRequestBuilder(propertyKey);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getEventProperty", localVarResponse);
        }
        return new ApiResponse<EventPropertyDetail>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventPropertyDetail>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getEventPropertyRequestBuilder(String propertyKey) throws ApiException {
    // verify the required parameter 'propertyKey' is set
    if (propertyKey == null) {
      throw new ApiException(400, "Missing the required parameter 'propertyKey' when calling getEventProperty");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/eventProperties/{propertyKey}"
        .replace("{propertyKey}", ApiClient.urlEncode(propertyKey.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets the properties of an event type
   * 
   * @param eventType The event type you&#39;re inquiring. (required)
   * @return EventType
   * @throws ApiException if fails to make API call
   */
  public EventType getEventType(String eventType) throws ApiException {
    ApiResponse<EventType> localVarResponse = getEventTypeWithHttpInfo(eventType);
    return localVarResponse.getData();
  }

  /**
   * Gets the properties of an event type
   * 
   * @param eventType The event type you&#39;re inquiring. (required)
   * @return ApiResponse&lt;EventType&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<EventType> getEventTypeWithHttpInfo(String eventType) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getEventTypeRequestBuilder(eventType);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getEventType", localVarResponse);
        }
        return new ApiResponse<EventType>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventType>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getEventTypeRequestBuilder(String eventType) throws ApiException {
    // verify the required parameter 'eventType' is set
    if (eventType == null) {
      throw new ApiException(400, "Missing the required parameter 'eventType' when calling getEventType");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/eventTypes/{eventType}"
        .replace("{eventType}", ApiClient.urlEncode(eventType.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists all event types
   * 
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The amount of event types in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used. (optional)
   * @return EventTypeList
   * @throws ApiException if fails to make API call
   */
  public EventTypeList getEventTypes(String nextPageKey, Long pageSize) throws ApiException {
    ApiResponse<EventTypeList> localVarResponse = getEventTypesWithHttpInfo(nextPageKey, pageSize);
    return localVarResponse.getData();
  }

  /**
   * Lists all event types
   * 
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The amount of event types in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used. (optional)
   * @return ApiResponse&lt;EventTypeList&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<EventTypeList> getEventTypesWithHttpInfo(String nextPageKey, Long pageSize) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getEventTypesRequestBuilder(nextPageKey, pageSize);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getEventTypes", localVarResponse);
        }
        return new ApiResponse<EventTypeList>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventTypeList>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getEventTypesRequestBuilder(String nextPageKey, Long pageSize) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/eventTypes";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nextPageKey", nextPageKey));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pageSize", pageSize));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists events within the specified timeframe
   * 
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The amount of events in a single response payload.   The maximal allowed page size is 1000.   If not set, 100 is used. (optional)
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param eventSelector Defines the scope of the query. Only events matching the specified criteria are included in the response.  You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. * Event ID: &#x60;eventId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;. * ID of related entity: &#x60;entityId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;. * Event status: &#x60;status(\&quot;OPEN\&quot;)&#x60; or &#x60;status(\&quot;CLOSED\&quot;)&#x60;. You can specify only one status. * Management zone ID: &#x60;managementZoneId(\&quot;123\&quot;, \&quot;321\&quot;)&#x60;. * Event type: &#x60;eventType(\&quot;event-type\&quot;)&#x60;. You can specify only one event type. You can fetch the list of possible event types with the [GET event types](https://dt-url.net/qc03u6w) call.  * Correlation ID: &#x60;correlationId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;. * Happened during maintenance (true, false): &#x60;underMaintenance(true)&#x60;.  * Notifications are suppressed (true, false): &#x60;suppressAlert(true)&#x60;.  * Problem creation is suppressed (true, false): &#x60;suppressProblem(true)&#x60;.  * Frequent event (true, false): &#x60;frequentEvent(true)&#x60;.  * Event property: &#x60;property.&lt;key&gt;(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;.  To set several criteria, separate them with commas (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)
   * @param entitySelector The entity scope of the query. You must set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;). All requested entities must be of the same type.   You can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name:   * &#x60;entityName.equals&#x60;: performs a non-casesensitive &#x60;EQUALS&#x60; query.   * &#x60;entityName.startsWith&#x60;: changes the operator to &#x60;BEGINS WITH&#x60;.   * &#x60;entityName.in&#x60;: enables you to provide multiple values. The &#x60;EQUALS&#x60; operator applies.   * &#x60;caseSensitive(entityName.equals(\&quot;value\&quot;))&#x60;: takes any entity name criterion as an arguments and makes the value case-sensitive. * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.&lt;operator&gt;(now-3h)&#x60;. Use any timestamp format from the **from**_/_**to** parameters.   The following operators are available:  * &#x60;lte&#x60;: earlier than or at the specified time  * &#x60;lt&#x60;: earlier than the specified time  * &#x60;gte&#x60;: later than or at the specified time  * &#x60;gt&#x60;: later than the specified time * Entity attribute: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. To fetch the list of available attributes, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **properties** field of the response.  * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60; and &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The criterion takes an entity selector as an attribute. To fetch the list of available relationships, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **fromRelationships** and **toRelationships** fields. * Negation: &#x60;not(&lt;criterion&gt;)&#x60;. Inverts any criterion except for **type**.   For more information, see [Entity selector](https://dt-url.net/apientityselector) in Dynatrace Documentation.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   Supported string length is 2,000 characters.   The number of entities that can be selected is limited to 10000. (optional)
   * @return EventList
   * @throws ApiException if fails to make API call
   */
  public EventList getEvents(String nextPageKey, Long pageSize, String from, String to, String eventSelector, String entitySelector) throws ApiException {
    ApiResponse<EventList> localVarResponse = getEventsWithHttpInfo(nextPageKey, pageSize, from, to, eventSelector, entitySelector);
    return localVarResponse.getData();
  }

  /**
   * Lists events within the specified timeframe
   * 
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The amount of events in a single response payload.   The maximal allowed page size is 1000.   If not set, 100 is used. (optional)
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param eventSelector Defines the scope of the query. Only events matching the specified criteria are included in the response.  You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. * Event ID: &#x60;eventId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;. * ID of related entity: &#x60;entityId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;. * Event status: &#x60;status(\&quot;OPEN\&quot;)&#x60; or &#x60;status(\&quot;CLOSED\&quot;)&#x60;. You can specify only one status. * Management zone ID: &#x60;managementZoneId(\&quot;123\&quot;, \&quot;321\&quot;)&#x60;. * Event type: &#x60;eventType(\&quot;event-type\&quot;)&#x60;. You can specify only one event type. You can fetch the list of possible event types with the [GET event types](https://dt-url.net/qc03u6w) call.  * Correlation ID: &#x60;correlationId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;. * Happened during maintenance (true, false): &#x60;underMaintenance(true)&#x60;.  * Notifications are suppressed (true, false): &#x60;suppressAlert(true)&#x60;.  * Problem creation is suppressed (true, false): &#x60;suppressProblem(true)&#x60;.  * Frequent event (true, false): &#x60;frequentEvent(true)&#x60;.  * Event property: &#x60;property.&lt;key&gt;(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;.  To set several criteria, separate them with commas (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)
   * @param entitySelector The entity scope of the query. You must set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;). All requested entities must be of the same type.   You can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name:   * &#x60;entityName.equals&#x60;: performs a non-casesensitive &#x60;EQUALS&#x60; query.   * &#x60;entityName.startsWith&#x60;: changes the operator to &#x60;BEGINS WITH&#x60;.   * &#x60;entityName.in&#x60;: enables you to provide multiple values. The &#x60;EQUALS&#x60; operator applies.   * &#x60;caseSensitive(entityName.equals(\&quot;value\&quot;))&#x60;: takes any entity name criterion as an arguments and makes the value case-sensitive. * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.&lt;operator&gt;(now-3h)&#x60;. Use any timestamp format from the **from**_/_**to** parameters.   The following operators are available:  * &#x60;lte&#x60;: earlier than or at the specified time  * &#x60;lt&#x60;: earlier than the specified time  * &#x60;gte&#x60;: later than or at the specified time  * &#x60;gt&#x60;: later than the specified time * Entity attribute: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. To fetch the list of available attributes, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **properties** field of the response.  * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60; and &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The criterion takes an entity selector as an attribute. To fetch the list of available relationships, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **fromRelationships** and **toRelationships** fields. * Negation: &#x60;not(&lt;criterion&gt;)&#x60;. Inverts any criterion except for **type**.   For more information, see [Entity selector](https://dt-url.net/apientityselector) in Dynatrace Documentation.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   Supported string length is 2,000 characters.   The number of entities that can be selected is limited to 10000. (optional)
   * @return ApiResponse&lt;EventList&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<EventList> getEventsWithHttpInfo(String nextPageKey, Long pageSize, String from, String to, String eventSelector, String entitySelector) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getEventsRequestBuilder(nextPageKey, pageSize, from, to, eventSelector, entitySelector);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getEvents", localVarResponse);
        }
        return new ApiResponse<EventList>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<EventList>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getEventsRequestBuilder(String nextPageKey, Long pageSize, String from, String to, String eventSelector, String entitySelector) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/events";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nextPageKey", nextPageKey));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pageSize", pageSize));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("from", from));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("to", to));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("eventSelector", eventSelector));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("entitySelector", entitySelector));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
