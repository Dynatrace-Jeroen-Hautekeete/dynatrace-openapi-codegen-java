/*
 * Dynatrace Environment API
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.dynatrace.apis.envv2.api;

import com.dynatrace.apis.envv2.ApiClient;
import com.dynatrace.apis.envv2.ApiException;
import com.dynatrace.apis.envv2.ApiResponse;
import com.dynatrace.apis.envv2.Pair;

import com.dynatrace.apis.envv2.model.RemediationItemList;
import com.dynatrace.apis.envv2.model.RemediationItemMuteStateChange;
import com.dynatrace.apis.envv2.model.SecurityProblemDetails;
import com.dynatrace.apis.envv2.model.SecurityProblemList;
import com.dynatrace.apis.envv2.model.SecurityProblemMute;
import com.dynatrace.apis.envv2.model.SecurityProblemUnmute;
import com.dynatrace.apis.envv2.model.VulnerableFunctionsContainer;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:06.080821500+01:00[Europe/Brussels]")
public class SecurityProblemsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public SecurityProblemsApi() {
    this(new ApiClient());
  }

  public SecurityProblemsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Lists remediation items of a third-party security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required third-party security problem. (required)
   * @param remediationItemSelector Defines the scope of the query. Only remediable entities matching the specified criteria are included in the response.  You can add one or more of the following criteria. Values are *not* case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Vulnerability state: &#x60;vulnerabilityState(\&quot;value\&quot;)&#x60;. Find the possible values in the description of the **vulnerabilityState** field of the response. If not set, all entities are returned. * Muted: &#x60;muted(\&quot;value\&quot;)&#x60;. Possible values are &#x60;TRUE&#x60; or &#x60;FALSE&#x60;. * Reachable data asset assessment: &#x60;assessment.dataAssets(\&quot;value\&quot;)&#x60; Possible values are &#x60;REACHABLE&#x60;, and &#x60;NOT_DETECTED&#x60;. * Network exposure assessment: &#x60;assessment.exposure(\&quot;value\&quot;)&#x60; Possible values are &#x60;PUBLIC_NETWORK&#x60;, and &#x60;NOT_DETECTED&#x60;. * Vulnerable function usage assessment: &#x60;assessment.vulnerableFunctionUsage(\&quot;value\&quot;)&#x60; Possible values are &#x60;IN_USE&#x60;, and &#x60;NOT_IN_USE&#x60;. * Vulnerable function in use contains: &#x60;assessment.vulnerableFunctionInUseContains(\&quot;value\&quot;)&#x60;. Possible values are &#x60;class::function&#x60;, &#x60;class::&#x60; and &#x60;function&#x60;. The &#x60;CONTAINS&#x60; operator is used. Only vulnerable functions in use are considered. * Assessment accuracy: &#x60;assessment.accuracy(\&quot;value\&quot;)&#x60; Possible values are &#x60;FULL&#x60; and &#x60;REDUCED&#x60;. * Entity name contains: &#x60;entityNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used.  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60; (optional)
   * @return RemediationItemList
   * @throws ApiException if fails to make API call
   */
  public RemediationItemList getRemediationItems(String id, String remediationItemSelector) throws ApiException {
    ApiResponse<RemediationItemList> localVarResponse = getRemediationItemsWithHttpInfo(id, remediationItemSelector);
    return localVarResponse.getData();
  }

  /**
   * Lists remediation items of a third-party security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required third-party security problem. (required)
   * @param remediationItemSelector Defines the scope of the query. Only remediable entities matching the specified criteria are included in the response.  You can add one or more of the following criteria. Values are *not* case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Vulnerability state: &#x60;vulnerabilityState(\&quot;value\&quot;)&#x60;. Find the possible values in the description of the **vulnerabilityState** field of the response. If not set, all entities are returned. * Muted: &#x60;muted(\&quot;value\&quot;)&#x60;. Possible values are &#x60;TRUE&#x60; or &#x60;FALSE&#x60;. * Reachable data asset assessment: &#x60;assessment.dataAssets(\&quot;value\&quot;)&#x60; Possible values are &#x60;REACHABLE&#x60;, and &#x60;NOT_DETECTED&#x60;. * Network exposure assessment: &#x60;assessment.exposure(\&quot;value\&quot;)&#x60; Possible values are &#x60;PUBLIC_NETWORK&#x60;, and &#x60;NOT_DETECTED&#x60;. * Vulnerable function usage assessment: &#x60;assessment.vulnerableFunctionUsage(\&quot;value\&quot;)&#x60; Possible values are &#x60;IN_USE&#x60;, and &#x60;NOT_IN_USE&#x60;. * Vulnerable function in use contains: &#x60;assessment.vulnerableFunctionInUseContains(\&quot;value\&quot;)&#x60;. Possible values are &#x60;class::function&#x60;, &#x60;class::&#x60; and &#x60;function&#x60;. The &#x60;CONTAINS&#x60; operator is used. Only vulnerable functions in use are considered. * Assessment accuracy: &#x60;assessment.accuracy(\&quot;value\&quot;)&#x60; Possible values are &#x60;FULL&#x60; and &#x60;REDUCED&#x60;. * Entity name contains: &#x60;entityNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used.  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60; (optional)
   * @return ApiResponse&lt;RemediationItemList&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<RemediationItemList> getRemediationItemsWithHttpInfo(String id, String remediationItemSelector) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getRemediationItemsRequestBuilder(id, remediationItemSelector);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getRemediationItems", localVarResponse);
        }
        return new ApiResponse<RemediationItemList>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<RemediationItemList>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getRemediationItemsRequestBuilder(String id, String remediationItemSelector) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getRemediationItems");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/securityProblems/{id}/remediationItems"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("remediationItemSelector", remediationItemSelector));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets parameters of a security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required security problem. (required)
   * @param fields A list of additional security problem properties you can add to the response.  The following properties are available (all other properties are always included and you can&#39;t remove them from the response):  * &#x60;riskAssessment&#x60;: A risk assessment of the security problem. * &#x60;managementZones&#x60;: The management zone where the security problem occurred. * &#x60;codeLevelVulnerabilityDetails&#x60;: Details of the code-level vulnerability. * &#x60;description&#x60;: The description of the vulnerability. * &#x60;events&#x60;: The security problem&#39;s last 10 events within the last 365 days, sorted from newest to oldest. * &#x60;vulnerableComponents&#x60;: A list of vulnerable components of the security problem within the provided filter range.  * &#x60;affectedEntities&#x60;: A list of affected entities of the security problem within the provided filter range.  * &#x60;exposedEntities&#x60;: A list of exposed entities of the security problem within the provided filter range.  * &#x60;reachableDataAssets&#x60;: A list of data assets reachable by affected entities of the security problem within the provided filter range.  * &#x60;relatedEntities&#x60;: A list of related entities of the security problem within the provided filter range.  * &#x60;relatedContainerImages&#x60;: A list of related container images of the security problem within the provided filter range.  * &#x60;relatedAttacks&#x60;: A list of attacks detected on the exposed security problem.   To add properties, specify them in a comma-separated list and prefix each property with a plus (for example, &#x60;+riskAssessment,+managementZones&#x60;).  (optional)
   * @param from Based on the timeframe start the affected-, related- and vulnerable entities are being calculated. You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the default timeframe start of 24 hours in the past is used (&#x60;now-24h&#x60;).  The timeframe start must not be older than 365 days. (optional)
   * @return SecurityProblemDetails
   * @throws ApiException if fails to make API call
   */
  public SecurityProblemDetails getSecurityProblem(String id, String fields, String from) throws ApiException {
    ApiResponse<SecurityProblemDetails> localVarResponse = getSecurityProblemWithHttpInfo(id, fields, from);
    return localVarResponse.getData();
  }

  /**
   * Gets parameters of a security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required security problem. (required)
   * @param fields A list of additional security problem properties you can add to the response.  The following properties are available (all other properties are always included and you can&#39;t remove them from the response):  * &#x60;riskAssessment&#x60;: A risk assessment of the security problem. * &#x60;managementZones&#x60;: The management zone where the security problem occurred. * &#x60;codeLevelVulnerabilityDetails&#x60;: Details of the code-level vulnerability. * &#x60;description&#x60;: The description of the vulnerability. * &#x60;events&#x60;: The security problem&#39;s last 10 events within the last 365 days, sorted from newest to oldest. * &#x60;vulnerableComponents&#x60;: A list of vulnerable components of the security problem within the provided filter range.  * &#x60;affectedEntities&#x60;: A list of affected entities of the security problem within the provided filter range.  * &#x60;exposedEntities&#x60;: A list of exposed entities of the security problem within the provided filter range.  * &#x60;reachableDataAssets&#x60;: A list of data assets reachable by affected entities of the security problem within the provided filter range.  * &#x60;relatedEntities&#x60;: A list of related entities of the security problem within the provided filter range.  * &#x60;relatedContainerImages&#x60;: A list of related container images of the security problem within the provided filter range.  * &#x60;relatedAttacks&#x60;: A list of attacks detected on the exposed security problem.   To add properties, specify them in a comma-separated list and prefix each property with a plus (for example, &#x60;+riskAssessment,+managementZones&#x60;).  (optional)
   * @param from Based on the timeframe start the affected-, related- and vulnerable entities are being calculated. You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the default timeframe start of 24 hours in the past is used (&#x60;now-24h&#x60;).  The timeframe start must not be older than 365 days. (optional)
   * @return ApiResponse&lt;SecurityProblemDetails&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SecurityProblemDetails> getSecurityProblemWithHttpInfo(String id, String fields, String from) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getSecurityProblemRequestBuilder(id, fields, from);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getSecurityProblem", localVarResponse);
        }
        return new ApiResponse<SecurityProblemDetails>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<SecurityProblemDetails>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getSecurityProblemRequestBuilder(String id, String fields, String from) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getSecurityProblem");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/securityProblems/{id}"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fields", fields));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("from", from));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists all security problems | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The amount of security problems in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used. (optional)
   * @param securityProblemSelector Defines the scope of the query. Only security problems matching the specified criteria are included in the response.  You can add one or more of the following criteria. Values are *not* case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Status: &#x60;status(\&quot;value\&quot;)&#x60;. Find the possible values in the description of the **status** field of the response. If not set, all security problems are returned. * Muted: &#x60;muted(\&quot;value\&quot;)&#x60;. Possible values are &#x60;TRUE&#x60; or &#x60;FALSE&#x60;. * Risk level: &#x60;riskLevel(\&quot;value\&quot;)&#x60;. The Davis risk level. Find the possible values in the description of the **riskLevel** field of the response. * Minimum risk score: &#x60;minRiskScore(\&quot;5.5\&quot;)&#x60;. The Davis minimum risk score. The &#x60;GREATER THAN OR EQUAL TO&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Maximum risk score: &#x60;maxRiskScore(\&quot;5.5\&quot;)&#x60;. The Davis maximum risk score. The &#x60;LESS THAN&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Base risk level: &#x60;baseRiskLevel(\&quot;value\&quot;)&#x60;. The Base risk level from the CVSS. Find the possible values in the description of the **riskLevel** field of the response. * Minimum base risk score: &#x60;minBaseRiskScore(\&quot;5.5\&quot;)&#x60;. The minimum base risk score from the CVSS. The &#x60;GREATER THAN OR EQUAL TO&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Maximum base risk score: &#x60;maxBaseRiskScore(\&quot;5.5\&quot;)&#x60;. The maximum base risk score from the CVSS. The &#x60;LESS THAN&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * External vulnerability ID contains: &#x60;externalVulnerabilityIdContains(\&quot;id-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * External vulnerability ID: &#x60;externalVulnerabilityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;.  * CVE ID: &#x60;cveId(\&quot;id\&quot;)&#x60;. * Risk assessment &#x60;riskAssessment(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60; Possible values are &#x60;EXPOSED&#x60;, &#x60;SENSITIVE&#x60;, &#x60;EXPLOIT&#x60;, &#x60;VULNERABLE_FUNCTION_IN_USE&#x60; and &#x60;ACCURACY_REDUCED&#x60;. * Related host ID: &#x60;relatedHostIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related host name: &#x60;relatedHostNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related host name contains: &#x60;relatedHostNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Related Kubernetes cluster ID: &#x60;relatedKubernetesClusterIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related Kubernetes cluster name: &#x60;relatedKubernetesClusterNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related Kubernetes cluster name contains: &#x60;relatedKubernetesClusterNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Related Kubernetes workload ID: &#x60;relatedKubernetesWorkloadIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related Kubernetes workload name: &#x60;relatedKubernetesWorkloadNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related Kubernetes workload name contains: &#x60;relatedKubernetesWorkloadNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Management zone ID: &#x60;managementZoneIds(\&quot;mzId-1\&quot;,\&quot;mzId-2\&quot;)&#x60;. * Management zone name: &#x60;managementZones(\&quot;name-1\&quot;,\&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Affected process group ID: &#x60;affectedPgIds(\&quot;pgId-1\&quot;, \&quot;pgId-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Affected process group name: &#x60;affectedPgNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Affected process group name contains: &#x60;affectedPgNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Vulnerable component ID: &#x60;vulnerableComponentIds(\&quot;componentId-1\&quot;, \&quot;componentId-2\&quot;)&#x60;. Specify component IDs here. * Vulnerable component name: &#x60;vulnerableComponentNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Vulnerable component name contains: &#x60;vulnerableComponentNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Host tags: &#x60;hostTags(\&quot;hostTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Process group tags: &#x60;pgTags(\&quot;pgTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Process group instance tags: &#x60;pgiTags(\&quot;pgiTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Tags: &#x60;tags(\&quot;tag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. This selector picks hosts, process groups, and process group instances at the same time. Maximum value length is 48 characters. * Display ID: &#x60;displayIds(\&quot;S-1234\&quot;,\&quot;S-5678\&quot;)&#x60;. The &#x60;EQUALS&#x60; operator is used. * Technology: &#x60;technology(\&quot;technology-1\&quot;,\&quot;technology-2\&quot;)&#x60;. Find the possible values in the description of the **technology** field of the response. The &#x60;EQUALS&#x60; operator is used. * Vulnerability type: &#x60;vulnerabilityType(\&quot;type-1\&quot;,\&quot;type-2\&quot;)&#x60;. Possible values are &#x60;THIRD_PARTY&#x60;, &#x60;CODE_LEVEL&#x60;, &#x60;RUNTIME&#x60;.  Risk score and risk category are mutually exclusive (cannot be used at the same time).  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60; (optional)
   * @param sort Specifies one or more fields for sorting the security problem list. Multiple fields can be concatenated using a comma (&#x60;,&#x60;) as a separator (e.g. &#x60;+status,-timestamp&#x60;).  You can sort by the following properties with a sign prefix for the sorting order.   * &#x60;status&#x60;: The security problem status (&#x60;+&#x60; open first or &#x60;-&#x60; resolved first)  * &#x60;muted&#x60;: The security problem mute state (&#x60;+&#x60; unmuted first or &#x60;-&#x60; muted first)  * &#x60;technology&#x60;: The security problem technology  * &#x60;firstSeenTimestamp&#x60;: The timestamp of the first occurrence of the security problem (&#x60;+&#x60; new problems first or &#x60;-&#x60; old problems first)  * &#x60;lastUpdatedTimestamp&#x60;: The timestamp of the last update of the security problem (&#x60;+&#x60; recently updated problems first or &#x60;-&#x60;  earlier updated problems first) * &#x60;securityProblemId&#x60;: The auto-generated ID of the security problem (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;externalVulnerabilityId&#x60;: The ID of the external vulnerability (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;displayId&#x60;: The display ID (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;riskAssessment.riskScore&#x60;: The Davis security score (&#x60;+&#x60; lower score first or &#x60;-&#x60; higher score first)  * &#x60;riskAssessment.riskLevel&#x60;: The Davis security level (&#x60;+&#x60; lower level first or &#x60;-&#x60; higher level first)  * &#x60;riskAssessment.exposure&#x60;: Whether the problem is exposed to the internet  * &#x60;riskAssessment.dataAssets&#x60;: Whether data assets are affected  * &#x60;riskAssessment.vulnerableFunctionUsage&#x60;: Whether vulnerable functions are used  * &#x60;riskAssessment.assessmentAccuracy&#x60;: The assessments accuracy (&#x60;+&#x60; less accuracy first or &#x60;-&#x60; more accuracy first)   If no prefix is set, &#x60;+&#x60; is used. (optional)
   * @param fields A list of additional security problem properties you can add to the response.  The following properties are available (all other properties are always included and you can&#39;t remove them from the response):  * &#x60;riskAssessment&#x60;: A risk assessment of the security problem. * &#x60;managementZones&#x60;: The management zone where the security problem occurred. * &#x60;codeLevelVulnerabilityDetails&#x60;: Details of the code-level vulnerability.  To add properties, specify them in a comma-separated list and prefix each property with a plus (for example, &#x60;+riskAssessment,+managementZones&#x60;).  (optional)
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of thirty days is used (&#x60;now-30d&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used.  The end of the timeframe must not be older than 365 days. (optional)
   * @return SecurityProblemList
   * @throws ApiException if fails to make API call
   */
  public SecurityProblemList getSecurityProblems(String nextPageKey, Long pageSize, String securityProblemSelector, String sort, String fields, String from, String to) throws ApiException {
    ApiResponse<SecurityProblemList> localVarResponse = getSecurityProblemsWithHttpInfo(nextPageKey, pageSize, securityProblemSelector, sort, fields, from, to);
    return localVarResponse.getData();
  }

  /**
   * Lists all security problems | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The amount of security problems in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used. (optional)
   * @param securityProblemSelector Defines the scope of the query. Only security problems matching the specified criteria are included in the response.  You can add one or more of the following criteria. Values are *not* case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Status: &#x60;status(\&quot;value\&quot;)&#x60;. Find the possible values in the description of the **status** field of the response. If not set, all security problems are returned. * Muted: &#x60;muted(\&quot;value\&quot;)&#x60;. Possible values are &#x60;TRUE&#x60; or &#x60;FALSE&#x60;. * Risk level: &#x60;riskLevel(\&quot;value\&quot;)&#x60;. The Davis risk level. Find the possible values in the description of the **riskLevel** field of the response. * Minimum risk score: &#x60;minRiskScore(\&quot;5.5\&quot;)&#x60;. The Davis minimum risk score. The &#x60;GREATER THAN OR EQUAL TO&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Maximum risk score: &#x60;maxRiskScore(\&quot;5.5\&quot;)&#x60;. The Davis maximum risk score. The &#x60;LESS THAN&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Base risk level: &#x60;baseRiskLevel(\&quot;value\&quot;)&#x60;. The Base risk level from the CVSS. Find the possible values in the description of the **riskLevel** field of the response. * Minimum base risk score: &#x60;minBaseRiskScore(\&quot;5.5\&quot;)&#x60;. The minimum base risk score from the CVSS. The &#x60;GREATER THAN OR EQUAL TO&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Maximum base risk score: &#x60;maxBaseRiskScore(\&quot;5.5\&quot;)&#x60;. The maximum base risk score from the CVSS. The &#x60;LESS THAN&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * External vulnerability ID contains: &#x60;externalVulnerabilityIdContains(\&quot;id-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * External vulnerability ID: &#x60;externalVulnerabilityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;.  * CVE ID: &#x60;cveId(\&quot;id\&quot;)&#x60;. * Risk assessment &#x60;riskAssessment(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60; Possible values are &#x60;EXPOSED&#x60;, &#x60;SENSITIVE&#x60;, &#x60;EXPLOIT&#x60;, &#x60;VULNERABLE_FUNCTION_IN_USE&#x60; and &#x60;ACCURACY_REDUCED&#x60;. * Related host ID: &#x60;relatedHostIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related host name: &#x60;relatedHostNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related host name contains: &#x60;relatedHostNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Related Kubernetes cluster ID: &#x60;relatedKubernetesClusterIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related Kubernetes cluster name: &#x60;relatedKubernetesClusterNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related Kubernetes cluster name contains: &#x60;relatedKubernetesClusterNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Related Kubernetes workload ID: &#x60;relatedKubernetesWorkloadIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related Kubernetes workload name: &#x60;relatedKubernetesWorkloadNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related Kubernetes workload name contains: &#x60;relatedKubernetesWorkloadNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Management zone ID: &#x60;managementZoneIds(\&quot;mzId-1\&quot;,\&quot;mzId-2\&quot;)&#x60;. * Management zone name: &#x60;managementZones(\&quot;name-1\&quot;,\&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Affected process group ID: &#x60;affectedPgIds(\&quot;pgId-1\&quot;, \&quot;pgId-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Affected process group name: &#x60;affectedPgNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Affected process group name contains: &#x60;affectedPgNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Vulnerable component ID: &#x60;vulnerableComponentIds(\&quot;componentId-1\&quot;, \&quot;componentId-2\&quot;)&#x60;. Specify component IDs here. * Vulnerable component name: &#x60;vulnerableComponentNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Vulnerable component name contains: &#x60;vulnerableComponentNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Host tags: &#x60;hostTags(\&quot;hostTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Process group tags: &#x60;pgTags(\&quot;pgTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Process group instance tags: &#x60;pgiTags(\&quot;pgiTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Tags: &#x60;tags(\&quot;tag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. This selector picks hosts, process groups, and process group instances at the same time. Maximum value length is 48 characters. * Display ID: &#x60;displayIds(\&quot;S-1234\&quot;,\&quot;S-5678\&quot;)&#x60;. The &#x60;EQUALS&#x60; operator is used. * Technology: &#x60;technology(\&quot;technology-1\&quot;,\&quot;technology-2\&quot;)&#x60;. Find the possible values in the description of the **technology** field of the response. The &#x60;EQUALS&#x60; operator is used. * Vulnerability type: &#x60;vulnerabilityType(\&quot;type-1\&quot;,\&quot;type-2\&quot;)&#x60;. Possible values are &#x60;THIRD_PARTY&#x60;, &#x60;CODE_LEVEL&#x60;, &#x60;RUNTIME&#x60;.  Risk score and risk category are mutually exclusive (cannot be used at the same time).  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60; (optional)
   * @param sort Specifies one or more fields for sorting the security problem list. Multiple fields can be concatenated using a comma (&#x60;,&#x60;) as a separator (e.g. &#x60;+status,-timestamp&#x60;).  You can sort by the following properties with a sign prefix for the sorting order.   * &#x60;status&#x60;: The security problem status (&#x60;+&#x60; open first or &#x60;-&#x60; resolved first)  * &#x60;muted&#x60;: The security problem mute state (&#x60;+&#x60; unmuted first or &#x60;-&#x60; muted first)  * &#x60;technology&#x60;: The security problem technology  * &#x60;firstSeenTimestamp&#x60;: The timestamp of the first occurrence of the security problem (&#x60;+&#x60; new problems first or &#x60;-&#x60; old problems first)  * &#x60;lastUpdatedTimestamp&#x60;: The timestamp of the last update of the security problem (&#x60;+&#x60; recently updated problems first or &#x60;-&#x60;  earlier updated problems first) * &#x60;securityProblemId&#x60;: The auto-generated ID of the security problem (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;externalVulnerabilityId&#x60;: The ID of the external vulnerability (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;displayId&#x60;: The display ID (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;riskAssessment.riskScore&#x60;: The Davis security score (&#x60;+&#x60; lower score first or &#x60;-&#x60; higher score first)  * &#x60;riskAssessment.riskLevel&#x60;: The Davis security level (&#x60;+&#x60; lower level first or &#x60;-&#x60; higher level first)  * &#x60;riskAssessment.exposure&#x60;: Whether the problem is exposed to the internet  * &#x60;riskAssessment.dataAssets&#x60;: Whether data assets are affected  * &#x60;riskAssessment.vulnerableFunctionUsage&#x60;: Whether vulnerable functions are used  * &#x60;riskAssessment.assessmentAccuracy&#x60;: The assessments accuracy (&#x60;+&#x60; less accuracy first or &#x60;-&#x60; more accuracy first)   If no prefix is set, &#x60;+&#x60; is used. (optional)
   * @param fields A list of additional security problem properties you can add to the response.  The following properties are available (all other properties are always included and you can&#39;t remove them from the response):  * &#x60;riskAssessment&#x60;: A risk assessment of the security problem. * &#x60;managementZones&#x60;: The management zone where the security problem occurred. * &#x60;codeLevelVulnerabilityDetails&#x60;: Details of the code-level vulnerability.  To add properties, specify them in a comma-separated list and prefix each property with a plus (for example, &#x60;+riskAssessment,+managementZones&#x60;).  (optional)
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of thirty days is used (&#x60;now-30d&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used.  The end of the timeframe must not be older than 365 days. (optional)
   * @return ApiResponse&lt;SecurityProblemList&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SecurityProblemList> getSecurityProblemsWithHttpInfo(String nextPageKey, Long pageSize, String securityProblemSelector, String sort, String fields, String from, String to) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getSecurityProblemsRequestBuilder(nextPageKey, pageSize, securityProblemSelector, sort, fields, from, to);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getSecurityProblems", localVarResponse);
        }
        return new ApiResponse<SecurityProblemList>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<SecurityProblemList>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getSecurityProblemsRequestBuilder(String nextPageKey, Long pageSize, String securityProblemSelector, String sort, String fields, String from, String to) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/securityProblems";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nextPageKey", nextPageKey));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pageSize", pageSize));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("securityProblemSelector", securityProblemSelector));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("sort", sort));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fields", fields));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("from", from));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("to", to));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists all vulnerable functions and their usage for a third-party security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required third-party security problem. (required)
   * @param vulnerableFunctionsSelector Defines the scope of the query. Only vulnerable functions matching the specified criteria are included in the response.  You can add the following criteria. Values are *not* case sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Management zone ID: &#x60;managementZoneIds(\&quot;mzId-1\&quot;,\&quot;mzId-2\&quot;)&#x60;. * Management zone name: &#x60;managementZones(\&quot;name-1\&quot;,\&quot;name-2\&quot;)&#x60;. Values are case sensitive. * Process group ID: &#x60;processGroupIds(\&quot;pgId-1\&quot;, \&quot;pgId-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Process group name: &#x60;processGroupNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case sensitive. * Process group name contains: &#x60;processGroupNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60; (optional)
   * @param groupBy Defines additional grouping types in which vulnerable functions should be displayed.  You can add one of the following grouping types.  * Process group: &#x60;PROCESS_GROUP&#x60; (optional)
   * @return VulnerableFunctionsContainer
   * @throws ApiException if fails to make API call
   */
  public VulnerableFunctionsContainer getVulnerableFunctions(String id, String vulnerableFunctionsSelector, String groupBy) throws ApiException {
    ApiResponse<VulnerableFunctionsContainer> localVarResponse = getVulnerableFunctionsWithHttpInfo(id, vulnerableFunctionsSelector, groupBy);
    return localVarResponse.getData();
  }

  /**
   * Lists all vulnerable functions and their usage for a third-party security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required third-party security problem. (required)
   * @param vulnerableFunctionsSelector Defines the scope of the query. Only vulnerable functions matching the specified criteria are included in the response.  You can add the following criteria. Values are *not* case sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Management zone ID: &#x60;managementZoneIds(\&quot;mzId-1\&quot;,\&quot;mzId-2\&quot;)&#x60;. * Management zone name: &#x60;managementZones(\&quot;name-1\&quot;,\&quot;name-2\&quot;)&#x60;. Values are case sensitive. * Process group ID: &#x60;processGroupIds(\&quot;pgId-1\&quot;, \&quot;pgId-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Process group name: &#x60;processGroupNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case sensitive. * Process group name contains: &#x60;processGroupNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60; (optional)
   * @param groupBy Defines additional grouping types in which vulnerable functions should be displayed.  You can add one of the following grouping types.  * Process group: &#x60;PROCESS_GROUP&#x60; (optional)
   * @return ApiResponse&lt;VulnerableFunctionsContainer&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<VulnerableFunctionsContainer> getVulnerableFunctionsWithHttpInfo(String id, String vulnerableFunctionsSelector, String groupBy) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getVulnerableFunctionsRequestBuilder(id, vulnerableFunctionsSelector, groupBy);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getVulnerableFunctions", localVarResponse);
        }
        return new ApiResponse<VulnerableFunctionsContainer>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<VulnerableFunctionsContainer>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getVulnerableFunctionsRequestBuilder(String id, String vulnerableFunctionsSelector, String groupBy) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling getVulnerableFunctions");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/securityProblems/{id}/vulnerableFunctions"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("vulnerableFunctionsSelector", vulnerableFunctionsSelector));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("groupBy", groupBy));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Mutes a security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required security problem. (required)
   * @param securityProblemMute The JSON body of the request. Contains the muting information. (optional)
   * @throws ApiException if fails to make API call
   */
  public void muteSecurityProblem(String id, SecurityProblemMute securityProblemMute) throws ApiException {
    muteSecurityProblemWithHttpInfo(id, securityProblemMute);
  }

  /**
   * Mutes a security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required security problem. (required)
   * @param securityProblemMute The JSON body of the request. Contains the muting information. (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> muteSecurityProblemWithHttpInfo(String id, SecurityProblemMute securityProblemMute) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = muteSecurityProblemRequestBuilder(id, securityProblemMute);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("muteSecurityProblem", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder muteSecurityProblemRequestBuilder(String id, SecurityProblemMute securityProblemMute) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling muteSecurityProblem");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/securityProblems/{id}/mute"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(securityProblemMute);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Sets the mute state of a remediation item | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required third-party security problem. (required)
   * @param itemId The ID of the remediation item. (required)
   * @param remediationItemMuteStateChange The JSON body of the request. Contains the mute state information to be applied. (optional)
   * @throws ApiException if fails to make API call
   */
  public void setRemediationItemMuteState(String id, String itemId, RemediationItemMuteStateChange remediationItemMuteStateChange) throws ApiException {
    setRemediationItemMuteStateWithHttpInfo(id, itemId, remediationItemMuteStateChange);
  }

  /**
   * Sets the mute state of a remediation item | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required third-party security problem. (required)
   * @param itemId The ID of the remediation item. (required)
   * @param remediationItemMuteStateChange The JSON body of the request. Contains the mute state information to be applied. (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> setRemediationItemMuteStateWithHttpInfo(String id, String itemId, RemediationItemMuteStateChange remediationItemMuteStateChange) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = setRemediationItemMuteStateRequestBuilder(id, itemId, remediationItemMuteStateChange);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("setRemediationItemMuteState", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder setRemediationItemMuteStateRequestBuilder(String id, String itemId, RemediationItemMuteStateChange remediationItemMuteStateChange) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling setRemediationItemMuteState");
    }
    // verify the required parameter 'itemId' is set
    if (itemId == null) {
      throw new ApiException(400, "Missing the required parameter 'itemId' when calling setRemediationItemMuteState");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/securityProblems/{id}/remediationItems/{itemId}/muteState"
        .replace("{id}", ApiClient.urlEncode(id.toString()))
        .replace("{itemId}", ApiClient.urlEncode(itemId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(remediationItemMuteStateChange);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Un-mutes a security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required security problem. (required)
   * @param securityProblemUnmute The JSON body of the request. Contains the un-muting information. (optional)
   * @throws ApiException if fails to make API call
   */
  public void unmuteSecurityProblem(String id, SecurityProblemUnmute securityProblemUnmute) throws ApiException {
    unmuteSecurityProblemWithHttpInfo(id, securityProblemUnmute);
  }

  /**
   * Un-mutes a security problem | maturity&#x3D;EARLY_ADOPTER
   * 
   * @param id The ID of the required security problem. (required)
   * @param securityProblemUnmute The JSON body of the request. Contains the un-muting information. (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> unmuteSecurityProblemWithHttpInfo(String id, SecurityProblemUnmute securityProblemUnmute) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = unmuteSecurityProblemRequestBuilder(id, securityProblemUnmute);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("unmuteSecurityProblem", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder unmuteSecurityProblemRequestBuilder(String id, SecurityProblemUnmute securityProblemUnmute) throws ApiException {
    // verify the required parameter 'id' is set
    if (id == null) {
      throw new ApiException(400, "Missing the required parameter 'id' when calling unmuteSecurityProblem");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/securityProblems/{id}/unmute"
        .replace("{id}", ApiClient.urlEncode(id.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(securityProblemUnmute);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
