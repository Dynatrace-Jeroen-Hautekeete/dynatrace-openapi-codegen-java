/*
 * Dynatrace Environment API
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.dynatrace.apis.envv2.api;

import com.dynatrace.apis.envv2.ApiClient;
import com.dynatrace.apis.envv2.ApiException;
import com.dynatrace.apis.envv2.ApiResponse;
import com.dynatrace.apis.envv2.Pair;

import com.dynatrace.apis.envv2.model.Comment;
import com.dynatrace.apis.envv2.model.CommentRequestDtoImpl;
import com.dynatrace.apis.envv2.model.CommentsList;
import com.dynatrace.apis.envv2.model.Problem;
import com.dynatrace.apis.envv2.model.ProblemCloseRequestDtoImpl;
import com.dynatrace.apis.envv2.model.ProblemCloseResult;
import com.dynatrace.apis.envv2.model.Problems;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:06.080821500+01:00[Europe/Brussels]")
public class ProblemsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public ProblemsApi() {
    this(new ApiClient());
  }

  public ProblemsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Closes the specified problem and adds a closing comment on it
   * 
   * @param problemId The ID of the required problem. (required)
   * @param problemCloseRequestDtoImpl The JSON body of the request. Contains the closing comment on the problem. (optional)
   * @return ProblemCloseResult
   * @throws ApiException if fails to make API call
   */
  public ProblemCloseResult closeProblem(String problemId, ProblemCloseRequestDtoImpl problemCloseRequestDtoImpl) throws ApiException {
    ApiResponse<ProblemCloseResult> localVarResponse = closeProblemWithHttpInfo(problemId, problemCloseRequestDtoImpl);
    return localVarResponse.getData();
  }

  /**
   * Closes the specified problem and adds a closing comment on it
   * 
   * @param problemId The ID of the required problem. (required)
   * @param problemCloseRequestDtoImpl The JSON body of the request. Contains the closing comment on the problem. (optional)
   * @return ApiResponse&lt;ProblemCloseResult&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ProblemCloseResult> closeProblemWithHttpInfo(String problemId, ProblemCloseRequestDtoImpl problemCloseRequestDtoImpl) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = closeProblemRequestBuilder(problemId, problemCloseRequestDtoImpl);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("closeProblem", localVarResponse);
        }
        return new ApiResponse<ProblemCloseResult>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ProblemCloseResult>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder closeProblemRequestBuilder(String problemId, ProblemCloseRequestDtoImpl problemCloseRequestDtoImpl) throws ApiException {
    // verify the required parameter 'problemId' is set
    if (problemId == null) {
      throw new ApiException(400, "Missing the required parameter 'problemId' when calling closeProblem");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/problems/{problemId}/close"
        .replace("{problemId}", ApiClient.urlEncode(problemId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(problemCloseRequestDtoImpl);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Adds a new comment on the specified problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param commentRequestDtoImpl The JSON body of the request. Contains the comment to be added. (optional)
   * @throws ApiException if fails to make API call
   */
  public void createComment(String problemId, CommentRequestDtoImpl commentRequestDtoImpl) throws ApiException {
    createCommentWithHttpInfo(problemId, commentRequestDtoImpl);
  }

  /**
   * Adds a new comment on the specified problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param commentRequestDtoImpl The JSON body of the request. Contains the comment to be added. (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> createCommentWithHttpInfo(String problemId, CommentRequestDtoImpl commentRequestDtoImpl) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = createCommentRequestBuilder(problemId, commentRequestDtoImpl);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("createComment", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder createCommentRequestBuilder(String problemId, CommentRequestDtoImpl commentRequestDtoImpl) throws ApiException {
    // verify the required parameter 'problemId' is set
    if (problemId == null) {
      throw new ApiException(400, "Missing the required parameter 'problemId' when calling createComment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/problems/{problemId}/comments"
        .replace("{problemId}", ApiClient.urlEncode(problemId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(commentRequestDtoImpl);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Deletes the specified comment from a problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param commentId The ID of the required comment. (required)
   * @throws ApiException if fails to make API call
   */
  public void deleteComment(String problemId, String commentId) throws ApiException {
    deleteCommentWithHttpInfo(problemId, commentId);
  }

  /**
   * Deletes the specified comment from a problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param commentId The ID of the required comment. (required)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> deleteCommentWithHttpInfo(String problemId, String commentId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = deleteCommentRequestBuilder(problemId, commentId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("deleteComment", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder deleteCommentRequestBuilder(String problemId, String commentId) throws ApiException {
    // verify the required parameter 'problemId' is set
    if (problemId == null) {
      throw new ApiException(400, "Missing the required parameter 'problemId' when calling deleteComment");
    }
    // verify the required parameter 'commentId' is set
    if (commentId == null) {
      throw new ApiException(400, "Missing the required parameter 'commentId' when calling deleteComment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/problems/{problemId}/comments/{commentId}"
        .replace("{problemId}", ApiClient.urlEncode(problemId.toString()))
        .replace("{commentId}", ApiClient.urlEncode(commentId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json");

    localVarRequestBuilder.method("DELETE", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets the specified comment on a problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param commentId The ID of the required comment. (required)
   * @return Comment
   * @throws ApiException if fails to make API call
   */
  public Comment getComment(String problemId, String commentId) throws ApiException {
    ApiResponse<Comment> localVarResponse = getCommentWithHttpInfo(problemId, commentId);
    return localVarResponse.getData();
  }

  /**
   * Gets the specified comment on a problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param commentId The ID of the required comment. (required)
   * @return ApiResponse&lt;Comment&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Comment> getCommentWithHttpInfo(String problemId, String commentId) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getCommentRequestBuilder(problemId, commentId);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getComment", localVarResponse);
        }
        return new ApiResponse<Comment>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Comment>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getCommentRequestBuilder(String problemId, String commentId) throws ApiException {
    // verify the required parameter 'problemId' is set
    if (problemId == null) {
      throw new ApiException(400, "Missing the required parameter 'problemId' when calling getComment");
    }
    // verify the required parameter 'commentId' is set
    if (commentId == null) {
      throw new ApiException(400, "Missing the required parameter 'commentId' when calling getComment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/problems/{problemId}/comments/{commentId}"
        .replace("{problemId}", ApiClient.urlEncode(problemId.toString()))
        .replace("{commentId}", ApiClient.urlEncode(commentId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets all comments on the specified problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)
   * @param pageSize The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)
   * @return CommentsList
   * @throws ApiException if fails to make API call
   */
  public CommentsList getComments(String problemId, String nextPageKey, Long pageSize) throws ApiException {
    ApiResponse<CommentsList> localVarResponse = getCommentsWithHttpInfo(problemId, nextPageKey, pageSize);
    return localVarResponse.getData();
  }

  /**
   * Gets all comments on the specified problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)
   * @param pageSize The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used. (optional)
   * @return ApiResponse&lt;CommentsList&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<CommentsList> getCommentsWithHttpInfo(String problemId, String nextPageKey, Long pageSize) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getCommentsRequestBuilder(problemId, nextPageKey, pageSize);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getComments", localVarResponse);
        }
        return new ApiResponse<CommentsList>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<CommentsList>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getCommentsRequestBuilder(String problemId, String nextPageKey, Long pageSize) throws ApiException {
    // verify the required parameter 'problemId' is set
    if (problemId == null) {
      throw new ApiException(400, "Missing the required parameter 'problemId' when calling getComments");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/problems/{problemId}/comments"
        .replace("{problemId}", ApiClient.urlEncode(problemId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nextPageKey", nextPageKey));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pageSize", pageSize));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets the properties of the specified problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param fields A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#39;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)
   * @return Problem
   * @throws ApiException if fails to make API call
   */
  public Problem getProblem(String problemId, String fields) throws ApiException {
    ApiResponse<Problem> localVarResponse = getProblemWithHttpInfo(problemId, fields);
    return localVarResponse.getData();
  }

  /**
   * Gets the properties of the specified problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param fields A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#39;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;). (optional)
   * @return ApiResponse&lt;Problem&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Problem> getProblemWithHttpInfo(String problemId, String fields) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getProblemRequestBuilder(problemId, fields);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getProblem", localVarResponse);
        }
        return new ApiResponse<Problem>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Problem>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getProblemRequestBuilder(String problemId, String fields) throws ApiException {
    // verify the required parameter 'problemId' is set
    if (problemId == null) {
      throw new ApiException(400, "Missing the required parameter 'problemId' when calling getProblem");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/problems/{problemId}"
        .replace("{problemId}", ApiClient.urlEncode(problemId.toString()));

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fields", fields));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Lists problems observed within the specified timeframe
   * 
   * @param fields A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#39;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#39;re requesting. (optional)
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)
   * @param pageSize The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param problemSelector Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name (contains, case-insensitive): &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Alerting profile name (exact match, case-insensitive): &#x60;problemFilterNames.equals(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;). The search value is limited to 30 characters.  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)
   * @param entitySelector The entity scope of the query. You must set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;). All requested entities must be of the same type.   You can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name:   * &#x60;entityName.equals&#x60;: performs a non-casesensitive &#x60;EQUALS&#x60; query.   * &#x60;entityName.startsWith&#x60;: changes the operator to &#x60;BEGINS WITH&#x60;.   * &#x60;entityName.in&#x60;: enables you to provide multiple values. The &#x60;EQUALS&#x60; operator applies.   * &#x60;caseSensitive(entityName.equals(\&quot;value\&quot;))&#x60;: takes any entity name criterion as an arguments and makes the value case-sensitive. * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.&lt;operator&gt;(now-3h)&#x60;. Use any timestamp format from the **from**_/_**to** parameters.   The following operators are available:  * &#x60;lte&#x60;: earlier than or at the specified time  * &#x60;lt&#x60;: earlier than the specified time  * &#x60;gte&#x60;: later than or at the specified time  * &#x60;gt&#x60;: later than the specified time * Entity attribute: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. To fetch the list of available attributes, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **properties** field of the response.  * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60; and &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The criterion takes an entity selector as an attribute. To fetch the list of available relationships, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **fromRelationships** and **toRelationships** fields. * Negation: &#x60;not(&lt;criterion&gt;)&#x60;. Inverts any criterion except for **type**.   For more information, see [Entity selector](https://dt-url.net/apientityselector) in Dynatrace Documentation.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   Supported string length is 2,000 characters.   The maximum number of entities that may be selected is limited to 10000.   (optional)
   * @param sort Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)
   * @return Problems
   * @throws ApiException if fails to make API call
   */
  public Problems getProblems(String fields, String nextPageKey, Long pageSize, String from, String to, String problemSelector, String entitySelector, String sort) throws ApiException {
    ApiResponse<Problems> localVarResponse = getProblemsWithHttpInfo(fields, nextPageKey, pageSize, from, to, problemSelector, entitySelector, sort);
    return localVarResponse.getData();
  }

  /**
   * Lists problems observed within the specified timeframe
   * 
   * @param fields A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#39;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#39;re requesting. (optional)
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.   (optional)
   * @param pageSize The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used. (optional)
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param problemSelector Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name (contains, case-insensitive): &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Alerting profile name (exact match, case-insensitive): &#x60;problemFilterNames.equals(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;). The search value is limited to 30 characters.  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.    (optional)
   * @param entitySelector The entity scope of the query. You must set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;). All requested entities must be of the same type.   You can add one or several of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;), otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name:   * &#x60;entityName.equals&#x60;: performs a non-casesensitive &#x60;EQUALS&#x60; query.   * &#x60;entityName.startsWith&#x60;: changes the operator to &#x60;BEGINS WITH&#x60;.   * &#x60;entityName.in&#x60;: enables you to provide multiple values. The &#x60;EQUALS&#x60; operator applies.   * &#x60;caseSensitive(entityName.equals(\&quot;value\&quot;))&#x60;: takes any entity name criterion as an arguments and makes the value case-sensitive. * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.&lt;operator&gt;(now-3h)&#x60;. Use any timestamp format from the **from**_/_**to** parameters.   The following operators are available:  * &#x60;lte&#x60;: earlier than or at the specified time  * &#x60;lt&#x60;: earlier than the specified time  * &#x60;gte&#x60;: later than or at the specified time  * &#x60;gt&#x60;: later than the specified time * Entity attribute: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. To fetch the list of available attributes, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **properties** field of the response.  * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60; and &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. The criterion takes an entity selector as an attribute. To fetch the list of available relationships, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **fromRelationships** and **toRelationships** fields. * Negation: &#x60;not(&lt;criterion&gt;)&#x60;. Inverts any criterion except for **type**.   For more information, see [Entity selector](https://dt-url.net/apientityselector) in Dynatrace Documentation.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in response.   Supported string length is 2,000 characters.   The maximum number of entities that may be selected is limited to 10000.   (optional)
   * @param sort Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first. (optional)
   * @return ApiResponse&lt;Problems&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Problems> getProblemsWithHttpInfo(String fields, String nextPageKey, Long pageSize, String from, String to, String problemSelector, String entitySelector, String sort) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getProblemsRequestBuilder(fields, nextPageKey, pageSize, from, to, problemSelector, entitySelector, sort);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getProblems", localVarResponse);
        }
        return new ApiResponse<Problems>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<Problems>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getProblemsRequestBuilder(String fields, String nextPageKey, Long pageSize, String from, String to, String problemSelector, String entitySelector, String sort) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/problems";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("fields", fields));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nextPageKey", nextPageKey));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pageSize", pageSize));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("from", from));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("to", to));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("problemSelector", problemSelector));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("entitySelector", entitySelector));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("sort", sort));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Updates the specified comment on a problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param commentId The ID of the required comment. (required)
   * @param commentRequestDtoImpl The JSON body of the request. Contains the updated comment. (optional)
   * @throws ApiException if fails to make API call
   */
  public void updateComment(String problemId, String commentId, CommentRequestDtoImpl commentRequestDtoImpl) throws ApiException {
    updateCommentWithHttpInfo(problemId, commentId, commentRequestDtoImpl);
  }

  /**
   * Updates the specified comment on a problem
   * 
   * @param problemId The ID of the required problem. (required)
   * @param commentId The ID of the required comment. (required)
   * @param commentRequestDtoImpl The JSON body of the request. Contains the updated comment. (optional)
   * @return ApiResponse&lt;Void&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<Void> updateCommentWithHttpInfo(String problemId, String commentId, CommentRequestDtoImpl commentRequestDtoImpl) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = updateCommentRequestBuilder(problemId, commentId, commentRequestDtoImpl);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("updateComment", localVarResponse);
        }
        return new ApiResponse<Void>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          
          null
        );
      } finally {
        // Drain the InputStream
        while (localVarResponse.body().read() != -1) {
            // Ignore
        }
        localVarResponse.body().close();
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder updateCommentRequestBuilder(String problemId, String commentId, CommentRequestDtoImpl commentRequestDtoImpl) throws ApiException {
    // verify the required parameter 'problemId' is set
    if (problemId == null) {
      throw new ApiException(400, "Missing the required parameter 'problemId' when calling updateComment");
    }
    // verify the required parameter 'commentId' is set
    if (commentId == null) {
      throw new ApiException(400, "Missing the required parameter 'commentId' when calling updateComment");
    }

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/problems/{problemId}/comments/{commentId}"
        .replace("{problemId}", ApiClient.urlEncode(problemId.toString()))
        .replace("{commentId}", ApiClient.urlEncode(commentId.toString()));

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(commentRequestDtoImpl);
      localVarRequestBuilder.method("PUT", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
