/*
 * Dynatrace Environment API
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.dynatrace.apis.envv2.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.dynatrace.apis.envv2.model.Invocation;
import com.dynatrace.apis.envv2.model.Rollup;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * A dimensional or series filter on a metric.
 */
@ApiModel(description = "A dimensional or series filter on a metric.")
@JsonPropertyOrder({
  Filter.JSON_PROPERTY_REFERENCE_VALUE,
  Filter.JSON_PROPERTY_TARGET_DIMENSION,
  Filter.JSON_PROPERTY_TARGET_DIMENSIONS,
  Filter.JSON_PROPERTY_REFERENCE_STRING,
  Filter.JSON_PROPERTY_ROLLUP,
  Filter.JSON_PROPERTY_REFERENCE_INVOCATION,
  Filter.JSON_PROPERTY_TYPE,
  Filter.JSON_PROPERTY_OPERANDS
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:06.080821500+01:00[Europe/Brussels]")
public class Filter {
  public static final String JSON_PROPERTY_REFERENCE_VALUE = "referenceValue";
  private BigDecimal referenceValue;

  public static final String JSON_PROPERTY_TARGET_DIMENSION = "targetDimension";
  private String targetDimension;

  public static final String JSON_PROPERTY_TARGET_DIMENSIONS = "targetDimensions";
  private List<String> targetDimensions = null;

  public static final String JSON_PROPERTY_REFERENCE_STRING = "referenceString";
  private String referenceString;

  public static final String JSON_PROPERTY_ROLLUP = "rollup";
  private Rollup rollup;

  public static final String JSON_PROPERTY_REFERENCE_INVOCATION = "referenceInvocation";
  private Invocation referenceInvocation;

  /**
   * Type of this filter, determines which other fields are present.Can be any of:  * &#x60;eq&#x60;, * &#x60;ne&#x60;, * &#x60;prefix&#x60;, * &#x60;in&#x60;, * &#x60;remainder&#x60;, * &#x60;suffix&#x60;, * &#x60;contains&#x60;, * &#x60;existsKey&#x60;, * &#x60;series&#x60;, * &#x60;or&#x60;, * &#x60;and&#x60;, * &#x60;not&#x60;, * &#x60;ge&#x60;, * &#x60;gt&#x60;, * &#x60;le&#x60;, * &#x60;lt&#x60;, * &#x60;otherwise&#x60;.
   */
  public enum TypeEnum {
    AND("and"),
    
    CONTAINS("contains"),
    
    EQ("eq"),
    
    EXISTSKEY("existsKey"),
    
    GE("ge"),
    
    GT("gt"),
    
    IN("in"),
    
    LE("le"),
    
    LT("lt"),
    
    NE("ne"),
    
    NOT("not"),
    
    OR("or"),
    
    OTHERWISE("otherwise"),
    
    PREFIX("prefix"),
    
    REMAINDER("remainder"),
    
    SERIES("series"),
    
    SUFFIX("suffix");

    private String value;

    TypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static TypeEnum fromValue(String value) {
      for (TypeEnum b : TypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_TYPE = "type";
  private TypeEnum type;

  public static final String JSON_PROPERTY_OPERANDS = "operands";
  private List<Filter> operands = null;

  public Filter() { 
  }

  public Filter referenceValue(BigDecimal referenceValue) {
    this.referenceValue = referenceValue;
    return this;
  }

   /**
   * For the operands of &#x60;series&#x60; filters that match against a number, holds the number to compare against.
   * @return referenceValue
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "For the operands of `series` filters that match against a number, holds the number to compare against.")
  @JsonProperty(JSON_PROPERTY_REFERENCE_VALUE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public BigDecimal getReferenceValue() {
    return referenceValue;
  }


  @JsonProperty(JSON_PROPERTY_REFERENCE_VALUE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReferenceValue(BigDecimal referenceValue) {
    this.referenceValue = referenceValue;
  }


  public Filter targetDimension(String targetDimension) {
    this.targetDimension = targetDimension;
    return this;
  }

   /**
   * If the type applies to a dimension, then holds the target dimension.
   * @return targetDimension
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If the type applies to a dimension, then holds the target dimension.")
  @JsonProperty(JSON_PROPERTY_TARGET_DIMENSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getTargetDimension() {
    return targetDimension;
  }


  @JsonProperty(JSON_PROPERTY_TARGET_DIMENSION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTargetDimension(String targetDimension) {
    this.targetDimension = targetDimension;
  }


  public Filter targetDimensions(List<String> targetDimensions) {
    this.targetDimensions = targetDimensions;
    return this;
  }

  public Filter addTargetDimensionsItem(String targetDimensionsItem) {
    if (this.targetDimensions == null) {
      this.targetDimensions = new ArrayList<>();
    }
    this.targetDimensions.add(targetDimensionsItem);
    return this;
  }

   /**
   * If the type applies to n dimensions, then holds the target dimensions. Currently only used for the &#x60;remainder&#x60; filter.
   * @return targetDimensions
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If the type applies to n dimensions, then holds the target dimensions. Currently only used for the `remainder` filter.")
  @JsonProperty(JSON_PROPERTY_TARGET_DIMENSIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<String> getTargetDimensions() {
    return targetDimensions;
  }


  @JsonProperty(JSON_PROPERTY_TARGET_DIMENSIONS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTargetDimensions(List<String> targetDimensions) {
    this.targetDimensions = targetDimensions;
  }


  public Filter referenceString(String referenceString) {
    this.referenceString = referenceString;
    return this;
  }

   /**
   * For filters that match a dimension against a valkue, such as &#x60;eq&#x60; or &#x60;ne&#x60;, holds the value to compare the dimension against.
   * @return referenceString
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "For filters that match a dimension against a valkue, such as `eq` or `ne`, holds the value to compare the dimension against.")
  @JsonProperty(JSON_PROPERTY_REFERENCE_STRING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getReferenceString() {
    return referenceString;
  }


  @JsonProperty(JSON_PROPERTY_REFERENCE_STRING)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReferenceString(String referenceString) {
    this.referenceString = referenceString;
  }


  public Filter rollup(Rollup rollup) {
    this.rollup = rollup;
    return this;
  }

   /**
   * Get rollup
   * @return rollup
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_ROLLUP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Rollup getRollup() {
    return rollup;
  }


  @JsonProperty(JSON_PROPERTY_ROLLUP)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRollup(Rollup rollup) {
    this.rollup = rollup;
  }


  public Filter referenceInvocation(Invocation referenceInvocation) {
    this.referenceInvocation = referenceInvocation;
    return this;
  }

   /**
   * Get referenceInvocation
   * @return referenceInvocation
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "")
  @JsonProperty(JSON_PROPERTY_REFERENCE_INVOCATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Invocation getReferenceInvocation() {
    return referenceInvocation;
  }


  @JsonProperty(JSON_PROPERTY_REFERENCE_INVOCATION)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReferenceInvocation(Invocation referenceInvocation) {
    this.referenceInvocation = referenceInvocation;
  }


  public Filter type(TypeEnum type) {
    this.type = type;
    return this;
  }

   /**
   * Type of this filter, determines which other fields are present.Can be any of:  * &#x60;eq&#x60;, * &#x60;ne&#x60;, * &#x60;prefix&#x60;, * &#x60;in&#x60;, * &#x60;remainder&#x60;, * &#x60;suffix&#x60;, * &#x60;contains&#x60;, * &#x60;existsKey&#x60;, * &#x60;series&#x60;, * &#x60;or&#x60;, * &#x60;and&#x60;, * &#x60;not&#x60;, * &#x60;ge&#x60;, * &#x60;gt&#x60;, * &#x60;le&#x60;, * &#x60;lt&#x60;, * &#x60;otherwise&#x60;.
   * @return type
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "Type of this filter, determines which other fields are present.Can be any of:  * `eq`, * `ne`, * `prefix`, * `in`, * `remainder`, * `suffix`, * `contains`, * `existsKey`, * `series`, * `or`, * `and`, * `not`, * `ge`, * `gt`, * `le`, * `lt`, * `otherwise`.")
  @JsonProperty(JSON_PROPERTY_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public TypeEnum getType() {
    return type;
  }


  @JsonProperty(JSON_PROPERTY_TYPE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setType(TypeEnum type) {
    this.type = type;
  }


  public Filter operands(List<Filter> operands) {
    this.operands = operands;
    return this;
  }

  public Filter addOperandsItem(Filter operandsItem) {
    if (this.operands == null) {
      this.operands = new ArrayList<>();
    }
    this.operands.add(operandsItem);
    return this;
  }

   /**
   * If the type is &#x60;not&#x60;, &#x60;and&#x60; or &#x60;or&#x60;, then holds the contained filters.
   * @return operands
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "If the type is `not`, `and` or `or`, then holds the contained filters.")
  @JsonProperty(JSON_PROPERTY_OPERANDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public List<Filter> getOperands() {
    return operands;
  }


  @JsonProperty(JSON_PROPERTY_OPERANDS)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOperands(List<Filter> operands) {
    this.operands = operands;
  }


  /**
   * Return true if this Filter object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Filter filter = (Filter) o;
    return Objects.equals(this.referenceValue, filter.referenceValue) &&
        Objects.equals(this.targetDimension, filter.targetDimension) &&
        Objects.equals(this.targetDimensions, filter.targetDimensions) &&
        Objects.equals(this.referenceString, filter.referenceString) &&
        Objects.equals(this.rollup, filter.rollup) &&
        Objects.equals(this.referenceInvocation, filter.referenceInvocation) &&
        Objects.equals(this.type, filter.type) &&
        Objects.equals(this.operands, filter.operands);
  }

  @Override
  public int hashCode() {
    return Objects.hash(referenceValue, targetDimension, targetDimensions, referenceString, rollup, referenceInvocation, type, operands);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Filter {\n");
    sb.append("    referenceValue: ").append(toIndentedString(referenceValue)).append("\n");
    sb.append("    targetDimension: ").append(toIndentedString(targetDimension)).append("\n");
    sb.append("    targetDimensions: ").append(toIndentedString(targetDimensions)).append("\n");
    sb.append("    referenceString: ").append(toIndentedString(referenceString)).append("\n");
    sb.append("    rollup: ").append(toIndentedString(rollup)).append("\n");
    sb.append("    referenceInvocation: ").append(toIndentedString(referenceInvocation)).append("\n");
    sb.append("    type: ").append(toIndentedString(type)).append("\n");
    sb.append("    operands: ").append(toIndentedString(operands)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

