/*
 * Dynatrace Environment API
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.dynatrace.apis.envv2.api;

import com.dynatrace.apis.envv2.ApiClient;
import com.dynatrace.apis.envv2.ApiException;
import com.dynatrace.apis.envv2.ApiResponse;
import com.dynatrace.apis.envv2.Pair;

import com.dynatrace.apis.envv2.model.AggregatedLog;
import com.dynatrace.apis.envv2.model.ErrorEnvelope;
import com.dynatrace.apis.envv2.model.ExportedLogRecordList;
import com.dynatrace.apis.envv2.model.LogRecordsList;
import com.dynatrace.apis.envv2.model.SuccessEnvelope;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

import java.util.ArrayList;
import java.util.StringJoiner;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Consumer;

@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:06.080821500+01:00[Europe/Brussels]")
public class LogsApi {
  private final HttpClient memberVarHttpClient;
  private final ObjectMapper memberVarObjectMapper;
  private final String memberVarBaseUri;
  private final Consumer<HttpRequest.Builder> memberVarInterceptor;
  private final Duration memberVarReadTimeout;
  private final Consumer<HttpResponse<InputStream>> memberVarResponseInterceptor;
  private final Consumer<HttpResponse<String>> memberVarAsyncResponseInterceptor;

  public LogsApi() {
    this(new ApiClient());
  }

  public LogsApi(ApiClient apiClient) {
    memberVarHttpClient = apiClient.getHttpClient();
    memberVarObjectMapper = apiClient.getObjectMapper();
    memberVarBaseUri = apiClient.getBaseUri();
    memberVarInterceptor = apiClient.getRequestInterceptor();
    memberVarReadTimeout = apiClient.getReadTimeout();
    memberVarResponseInterceptor = apiClient.getResponseInterceptor();
    memberVarAsyncResponseInterceptor = apiClient.getAsyncResponseInterceptor();
  }

  protected ApiException getApiException(String operationId, HttpResponse<InputStream> response) throws IOException {
    String body = response.body() == null ? null : new String(response.body().readAllBytes());
    String message = formatExceptionMessage(operationId, response.statusCode(), body);
    return new ApiException(response.statusCode(), message, response.headers(), body);
  }

  private String formatExceptionMessage(String operationId, int statusCode, String body) {
    if (body == null || body.isEmpty()) {
      body = "[no body]";
    }
    return operationId + " call failed with: " + statusCode + " - " + body;
  }

  /**
   * Exports log records | maturity&#x3D;EARLY_ADOPTER
   * Returns the first *X* records (specified in the **pageSize** query parameter).   Unlike the **search** API, this API does not split the result into slices and has no limit for the total number of records. Log records are sorted by the criteria specified in the **sort** query parameter.   In order to fetch large amount of records (exceeding the **pageSize** value), one should repeat the **export** call with **nextPageKey** param.  
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The number of results per result page. (optional, default to 1000)
   * @param query The log search query.   The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). (optional, default to )
   * @param sort Defines the ordering of the log records.  Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied.   Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first).   When millisecond resolution provided by the timestamp is not enough, log records are sorted based on the order in which they appear in the log source (remote process writing to REST API endpoint or remote process from which logs are collected). (optional, default to -timestamp)
   * @return ExportedLogRecordList
   * @throws ApiException if fails to make API call
   */
  public ExportedLogRecordList exportLogRecords(String from, String to, String nextPageKey, Long pageSize, String query, String sort) throws ApiException {
    ApiResponse<ExportedLogRecordList> localVarResponse = exportLogRecordsWithHttpInfo(from, to, nextPageKey, pageSize, query, sort);
    return localVarResponse.getData();
  }

  /**
   * Exports log records | maturity&#x3D;EARLY_ADOPTER
   * Returns the first *X* records (specified in the **pageSize** query parameter).   Unlike the **search** API, this API does not split the result into slices and has no limit for the total number of records. Log records are sorted by the criteria specified in the **sort** query parameter.   In order to fetch large amount of records (exceeding the **pageSize** value), one should repeat the **export** call with **nextPageKey** param.  
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param nextPageKey The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters.  (optional)
   * @param pageSize The number of results per result page. (optional, default to 1000)
   * @param query The log search query.   The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). (optional, default to )
   * @param sort Defines the ordering of the log records.  Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied.   Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first).   When millisecond resolution provided by the timestamp is not enough, log records are sorted based on the order in which they appear in the log source (remote process writing to REST API endpoint or remote process from which logs are collected). (optional, default to -timestamp)
   * @return ApiResponse&lt;ExportedLogRecordList&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<ExportedLogRecordList> exportLogRecordsWithHttpInfo(String from, String to, String nextPageKey, Long pageSize, String query, String sort) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = exportLogRecordsRequestBuilder(from, to, nextPageKey, pageSize, query, sort);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("exportLogRecords", localVarResponse);
        }
        return new ApiResponse<ExportedLogRecordList>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<ExportedLogRecordList>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder exportLogRecordsRequestBuilder(String from, String to, String nextPageKey, Long pageSize, String query, String sort) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/logs/export";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("from", from));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("to", to));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nextPageKey", nextPageKey));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("pageSize", pageSize));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("query", query));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("sort", sort));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER
   * Returns the aggregated number of occurrences of log values divided into time slots.   It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param query The log search query.   The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). (optional, default to )
   * @param timeBuckets The number of time slots in the result.   The query timeframe is divided equally into the specified number of slots.   The minimum length of a slot is 1 ms.   If not set, 1 is used. (optional, default to 1)
   * @param maxGroupValues The maximum number of values in each group.   You can get up to 100 values per group.   If not set, 10 is used. (optional, default to 10)
   * @param groupBy The groupings to be included in the response.   You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;.   If not set, all possible groups are returned. You can use this option to check for possible grouping values.   Unique log data attributes (high-cardinality attributes) for example, &#x60;span_id&#x60; or &#x60;trace_id&#x60; cannot be used for grouping. (optional
   * @return AggregatedLog
   * @throws ApiException if fails to make API call
   */
  public AggregatedLog getLogHistogramData(String from, String to, String query, Integer timeBuckets, Integer maxGroupValues, List<String> groupBy) throws ApiException {
    ApiResponse<AggregatedLog> localVarResponse = getLogHistogramDataWithHttpInfo(from, to, query, timeBuckets, maxGroupValues, groupBy);
    return localVarResponse.getData();
  }

  /**
   * Gets aggregated log records | maturity&#x3D;EARLY_ADOPTER
   * Returns the aggregated number of occurrences of log values divided into time slots.   It is possible that the timeframe covered by results exceeds the specified timeframe. In that case the request returns fewer time slots than specified in the **timeBuckets** query parameter.
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param query The log search query.   The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). (optional, default to )
   * @param timeBuckets The number of time slots in the result.   The query timeframe is divided equally into the specified number of slots.   The minimum length of a slot is 1 ms.   If not set, 1 is used. (optional, default to 1)
   * @param maxGroupValues The maximum number of values in each group.   You can get up to 100 values per group.   If not set, 10 is used. (optional, default to 10)
   * @param groupBy The groupings to be included in the response.   You can specify several groups in the following format: &#x60;groupBy&#x3D;status&amp;groupBy&#x3D;log.source&#x60;.   If not set, all possible groups are returned. You can use this option to check for possible grouping values.   Unique log data attributes (high-cardinality attributes) for example, &#x60;span_id&#x60; or &#x60;trace_id&#x60; cannot be used for grouping. (optional
   * @return ApiResponse&lt;AggregatedLog&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<AggregatedLog> getLogHistogramDataWithHttpInfo(String from, String to, String query, Integer timeBuckets, Integer maxGroupValues, List<String> groupBy) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getLogHistogramDataRequestBuilder(from, to, query, timeBuckets, maxGroupValues, groupBy);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getLogHistogramData", localVarResponse);
        }
        return new ApiResponse<AggregatedLog>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<AggregatedLog>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getLogHistogramDataRequestBuilder(String from, String to, String query, Integer timeBuckets, Integer maxGroupValues, List<String> groupBy) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/logs/aggregate";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("from", from));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("to", to));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("query", query));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("timeBuckets", timeBuckets));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("maxGroupValues", maxGroupValues));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("multi", "groupBy", groupBy));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Reads log records | maturity&#x3D;EARLY_ADOPTER
   * Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter.   If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on.   Results can be distributed unevenly between slices and some slices might be empty.
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param limit The desired amount of log records.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)
   * @param query The log search query.   The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). (optional, default to )
   * @param sort Defines the ordering of the log records.  Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied.   Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first).   When millisecond resolution provided by the timestamp is not enough, log records are sorted based on the order in which they appear in the log source (remote process writing to REST API endpoint or remote process from which logs are collected). (optional, default to -timestamp)
   * @param nextSliceKey The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response.   The first slice is always returned if you don&#39;t specify this parameter.   If this parameter is set, all other query parameters are ignored. (optional)
   * @return LogRecordsList
   * @throws ApiException if fails to make API call
   */
  public LogRecordsList getLogRecords(String from, String to, Integer limit, String query, String sort, String nextSliceKey) throws ApiException {
    ApiResponse<LogRecordsList> localVarResponse = getLogRecordsWithHttpInfo(from, to, limit, query, sort, nextSliceKey);
    return localVarResponse.getData();
  }

  /**
   * Reads log records | maturity&#x3D;EARLY_ADOPTER
   * Returns the first *X* records (specified in the **limit** query parameter). Log records are sorted by the criteria specified in the **sort** query parameter.   If the query is too large to be processed in a single request, it is divided into slices. In that case the first response contains the **nextSliceKey** cursor for the second slice. Use it in the **nextSliceKey** query parameter to obtain the second slice, which contains **nextSliceKey** cursor for the third slice, and so on.   Results can be distributed unevenly between slices and some slices might be empty.
   * @param from The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;). (optional)
   * @param to The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used. (optional)
   * @param limit The desired amount of log records.   The maximal allowed limit is 1000.   If not set, 1000 is used. (optional, default to 1000)
   * @param query The log search query.   The query must use the [Dynatrace search query language](https://dt-url.net/pe03s6f). (optional, default to )
   * @param sort Defines the ordering of the log records.  Each field has a sign prefix (+/-) for sorting order. If no sign prefix is set, then the &#x60;+&#x60; option will be applied.   Currently, ordering is available only for the timestamp (+timestamp for the oldest records first, or -timestamp for the newest records first).   When millisecond resolution provided by the timestamp is not enough, log records are sorted based on the order in which they appear in the log source (remote process writing to REST API endpoint or remote process from which logs are collected). (optional, default to -timestamp)
   * @param nextSliceKey The cursor for the next slice of results. You can find it in the **nextSliceKey** field of the previous response.   The first slice is always returned if you don&#39;t specify this parameter.   If this parameter is set, all other query parameters are ignored. (optional)
   * @return ApiResponse&lt;LogRecordsList&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<LogRecordsList> getLogRecordsWithHttpInfo(String from, String to, Integer limit, String query, String sort, String nextSliceKey) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = getLogRecordsRequestBuilder(from, to, limit, query, sort, nextSliceKey);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("getLogRecords", localVarResponse);
        }
        return new ApiResponse<LogRecordsList>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<LogRecordsList>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder getLogRecordsRequestBuilder(String from, String to, Integer limit, String query, String sort, String nextSliceKey) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/logs/search";

    List<Pair> localVarQueryParams = new ArrayList<>();
    localVarQueryParams.addAll(ApiClient.parameterToPairs("from", from));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("to", to));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("limit", limit));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("query", query));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("sort", sort));
    localVarQueryParams.addAll(ApiClient.parameterToPairs("nextSliceKey", nextSliceKey));

    if (!localVarQueryParams.isEmpty()) {
      StringJoiner queryJoiner = new StringJoiner("&");
      localVarQueryParams.forEach(p -> queryJoiner.add(p.getName() + '=' + p.getValue()));
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath + '?' + queryJoiner.toString()));
    } else {
      localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));
    }

    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    localVarRequestBuilder.method("GET", HttpRequest.BodyPublishers.noBody());
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
  /**
   * Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER
   * Ingested logs are stored in the indexed log storage.   This endpoint requires an ActiveGate with the **Log Analytics Collector** module enabled.   The maximum payload size of a single request is **5 MB**. Requests with a greater payload are rejected, and the API returns a 413 response code.  If the ingested payload is a JSON array, the maximum array size is **5000**. Requests with a greater payload are rejected, and the API returns a 413 response code.  &lt;br /&gt;**Log events per minute (SaaS)**:   Trial tenants: 10k, paid one: 100k per minute by default.   If your log data stream within your cluster exceeds the limit, all log events above the limit are ignored.   &lt;br /&gt;**Log events per minute (Managed)**:   10k/minute per cluster by default.   If your log data stream within your cluster exceeds the limit, all log events above the limit are ignored.   If you increase resources (RAM) in your nodes, you can increase the limit based on the cluster resources size using an API call or Cluster Management Console (CMC).   &lt;br /&gt;Refresh cluster limit using the API call   See [Update log events per cluster for Log Monitoring](https://dt-url.net/f123yeu).   &lt;br /&gt;Refresh cluster limit using Cluster Management Console (CMC)   1. In the CMC, select **Environments** and the environment for which you wish to update the total log events per cluster.   2. On the environment details page, in the **Cluster overload prevention settings** section, select the **Refresh cluster limit**.   **High-cardinality attributes:**   Unique log data attributes (high-cardinality attributes) such as &#x60;span_id&#x60; and &#x60;trace_id&#x60; generate unnecessarily excessive facet lists that may impact log viewer performance. Because of this, they aren&#39;t listed in log viewer facets. You can still use them in a log viewer advanced search query.   
   * @param body The body of the request. Contains one or more log events to be ingested.   The endpoint accepts one of the following payload types, defined by the **Accept** header:   * &#x60;text/plain&#x60;: supports only one log event.  * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)
   * @return SuccessEnvelope
   * @throws ApiException if fails to make API call
   */
  public SuccessEnvelope storeLog(Object body) throws ApiException {
    ApiResponse<SuccessEnvelope> localVarResponse = storeLogWithHttpInfo(body);
    return localVarResponse.getData();
  }

  /**
   * Pushes log records to Dynatrace | maturity&#x3D;EARLY_ADOPTER
   * Ingested logs are stored in the indexed log storage.   This endpoint requires an ActiveGate with the **Log Analytics Collector** module enabled.   The maximum payload size of a single request is **5 MB**. Requests with a greater payload are rejected, and the API returns a 413 response code.  If the ingested payload is a JSON array, the maximum array size is **5000**. Requests with a greater payload are rejected, and the API returns a 413 response code.  &lt;br /&gt;**Log events per minute (SaaS)**:   Trial tenants: 10k, paid one: 100k per minute by default.   If your log data stream within your cluster exceeds the limit, all log events above the limit are ignored.   &lt;br /&gt;**Log events per minute (Managed)**:   10k/minute per cluster by default.   If your log data stream within your cluster exceeds the limit, all log events above the limit are ignored.   If you increase resources (RAM) in your nodes, you can increase the limit based on the cluster resources size using an API call or Cluster Management Console (CMC).   &lt;br /&gt;Refresh cluster limit using the API call   See [Update log events per cluster for Log Monitoring](https://dt-url.net/f123yeu).   &lt;br /&gt;Refresh cluster limit using Cluster Management Console (CMC)   1. In the CMC, select **Environments** and the environment for which you wish to update the total log events per cluster.   2. On the environment details page, in the **Cluster overload prevention settings** section, select the **Refresh cluster limit**.   **High-cardinality attributes:**   Unique log data attributes (high-cardinality attributes) such as &#x60;span_id&#x60; and &#x60;trace_id&#x60; generate unnecessarily excessive facet lists that may impact log viewer performance. Because of this, they aren&#39;t listed in log viewer facets. You can still use them in a log viewer advanced search query.   
   * @param body The body of the request. Contains one or more log events to be ingested.   The endpoint accepts one of the following payload types, defined by the **Accept** header:   * &#x60;text/plain&#x60;: supports only one log event.  * &#x60;application/json&#x60;: supports multiple log events in a single payload. (optional)
   * @return ApiResponse&lt;SuccessEnvelope&gt;
   * @throws ApiException if fails to make API call
   */
  public ApiResponse<SuccessEnvelope> storeLogWithHttpInfo(Object body) throws ApiException {
    HttpRequest.Builder localVarRequestBuilder = storeLogRequestBuilder(body);
    try {
      HttpResponse<InputStream> localVarResponse = memberVarHttpClient.send(
          localVarRequestBuilder.build(),
          HttpResponse.BodyHandlers.ofInputStream());
      if (memberVarResponseInterceptor != null) {
        memberVarResponseInterceptor.accept(localVarResponse);
      }
      try {
        if (localVarResponse.statusCode()/ 100 != 2) {
          throw getApiException("storeLog", localVarResponse);
        }
        return new ApiResponse<SuccessEnvelope>(
          localVarResponse.statusCode(),
          localVarResponse.headers().map(),
          memberVarObjectMapper.readValue(localVarResponse.body(), new TypeReference<SuccessEnvelope>() {}) // closes the InputStream
          
        );
      } finally {
      }
    } catch (IOException e) {
      throw new ApiException(e);
    }
    catch (InterruptedException e) {
      Thread.currentThread().interrupt();
      throw new ApiException(e);
    }
  }

  private HttpRequest.Builder storeLogRequestBuilder(Object body) throws ApiException {

    HttpRequest.Builder localVarRequestBuilder = HttpRequest.newBuilder();

    String localVarPath = "/logs/ingest";

    localVarRequestBuilder.uri(URI.create(memberVarBaseUri + localVarPath));

    localVarRequestBuilder.header("Content-Type", "application/json; charset&#x3D;utf-8");
    localVarRequestBuilder.header("Accept", "application/json; charset&#x3D;utf-8");

    try {
      byte[] localVarPostBody = memberVarObjectMapper.writeValueAsBytes(body);
      localVarRequestBuilder.method("POST", HttpRequest.BodyPublishers.ofByteArray(localVarPostBody));
    } catch (IOException e) {
      throw new ApiException(e);
    }
    if (memberVarReadTimeout != null) {
      localVarRequestBuilder.timeout(memberVarReadTimeout);
    }
    if (memberVarInterceptor != null) {
      memberVarInterceptor.accept(localVarRequestBuilder);
    }
    return localVarRequestBuilder;
  }
}
