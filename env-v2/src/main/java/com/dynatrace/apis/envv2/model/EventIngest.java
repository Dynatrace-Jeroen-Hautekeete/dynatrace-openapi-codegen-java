/*
 * Dynatrace Environment API
 *  Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.
 *
 * The version of the OpenAPI document: 2.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.dynatrace.apis.envv2.model;

import java.util.Objects;
import java.util.Arrays;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.util.HashMap;
import java.util.Map;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;


/**
 * The configuration of an event to be ingested.
 */
@ApiModel(description = "The configuration of an event to be ingested.")
@JsonPropertyOrder({
  EventIngest.JSON_PROPERTY_EVENT_TYPE,
  EventIngest.JSON_PROPERTY_TITLE,
  EventIngest.JSON_PROPERTY_START_TIME,
  EventIngest.JSON_PROPERTY_END_TIME,
  EventIngest.JSON_PROPERTY_TIMEOUT,
  EventIngest.JSON_PROPERTY_ENTITY_SELECTOR,
  EventIngest.JSON_PROPERTY_PROPERTIES
})
@javax.annotation.processing.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2022-11-02T15:08:06.080821500+01:00[Europe/Brussels]")
public class EventIngest {
  /**
   * The type of the event.
   */
  public enum EventTypeEnum {
    AVAILABILITY_EVENT("AVAILABILITY_EVENT"),
    
    CUSTOM_ALERT("CUSTOM_ALERT"),
    
    CUSTOM_ANNOTATION("CUSTOM_ANNOTATION"),
    
    CUSTOM_CONFIGURATION("CUSTOM_CONFIGURATION"),
    
    CUSTOM_DEPLOYMENT("CUSTOM_DEPLOYMENT"),
    
    CUSTOM_INFO("CUSTOM_INFO"),
    
    ERROR_EVENT("ERROR_EVENT"),
    
    MARKED_FOR_TERMINATION("MARKED_FOR_TERMINATION"),
    
    PERFORMANCE_EVENT("PERFORMANCE_EVENT"),
    
    RESOURCE_CONTENTION_EVENT("RESOURCE_CONTENTION_EVENT");

    private String value;

    EventTypeEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static EventTypeEnum fromValue(String value) {
      for (EventTypeEnum b : EventTypeEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_EVENT_TYPE = "eventType";
  private EventTypeEnum eventType;

  public static final String JSON_PROPERTY_TITLE = "title";
  private String title;

  public static final String JSON_PROPERTY_START_TIME = "startTime";
  private Long startTime;

  public static final String JSON_PROPERTY_END_TIME = "endTime";
  private Long endTime;

  public static final String JSON_PROPERTY_TIMEOUT = "timeout";
  private Integer timeout;

  public static final String JSON_PROPERTY_ENTITY_SELECTOR = "entitySelector";
  private String entitySelector;

  public static final String JSON_PROPERTY_PROPERTIES = "properties";
  private Map<String, String> properties = null;

  public EventIngest() { 
  }

  public EventIngest eventType(EventTypeEnum eventType) {
    this.eventType = eventType;
    return this;
  }

   /**
   * The type of the event.
   * @return eventType
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The type of the event.")
  @JsonProperty(JSON_PROPERTY_EVENT_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public EventTypeEnum getEventType() {
    return eventType;
  }


  @JsonProperty(JSON_PROPERTY_EVENT_TYPE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setEventType(EventTypeEnum eventType) {
    this.eventType = eventType;
  }


  public EventIngest title(String title) {
    this.title = title;
    return this;
  }

   /**
   * The title of the event.
   * @return title
  **/
  @javax.annotation.Nonnull
  @ApiModelProperty(required = true, value = "The title of the event.")
  @JsonProperty(JSON_PROPERTY_TITLE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getTitle() {
    return title;
  }


  @JsonProperty(JSON_PROPERTY_TITLE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTitle(String title) {
    this.title = title;
  }


  public EventIngest startTime(Long startTime) {
    this.startTime = startTime;
    return this;
  }

   /**
   * The start time of the event, in UTC milliseconds.  If not set, the current timestamp is used.  Depending on the event type, the start time must not lie in the future more than 5 minutes for trigger events and 7 days for info events.
   * @return startTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The start time of the event, in UTC milliseconds.  If not set, the current timestamp is used.  Depending on the event type, the start time must not lie in the future more than 5 minutes for trigger events and 7 days for info events.")
  @JsonProperty(JSON_PROPERTY_START_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getStartTime() {
    return startTime;
  }


  @JsonProperty(JSON_PROPERTY_START_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStartTime(Long startTime) {
    this.startTime = startTime;
  }


  public EventIngest endTime(Long endTime) {
    this.endTime = endTime;
    return this;
  }

   /**
   * The end time of the event, in UTC milliseconds.  If not set, the start time plus timeout is used.
   * @return endTime
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The end time of the event, in UTC milliseconds.  If not set, the start time plus timeout is used.")
  @JsonProperty(JSON_PROPERTY_END_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getEndTime() {
    return endTime;
  }


  @JsonProperty(JSON_PROPERTY_END_TIME)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEndTime(Long endTime) {
    this.endTime = endTime;
  }


  public EventIngest timeout(Integer timeout) {
    this.timeout = timeout;
    return this;
  }

   /**
   * The timeout of the event, in minutes.  If not set, 15 is used.  The timeout will automatically be capped to a maximum of 360 minutes (6 hours).  Problem-opening events can be refreshed and therefore kept open by sending the same payload again.
   * @return timeout
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The timeout of the event, in minutes.  If not set, 15 is used.  The timeout will automatically be capped to a maximum of 360 minutes (6 hours).  Problem-opening events can be refreshed and therefore kept open by sending the same payload again.")
  @JsonProperty(JSON_PROPERTY_TIMEOUT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Integer getTimeout() {
    return timeout;
  }


  @JsonProperty(JSON_PROPERTY_TIMEOUT)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTimeout(Integer timeout) {
    this.timeout = timeout;
  }


  public EventIngest entitySelector(String entitySelector) {
    this.entitySelector = entitySelector;
    return this;
  }

   /**
   * The [entity selector](https://dt-url.net/apientityselector), defining a set of Dynatrace entities to be associated with the event.  Only entities that have been active within the last 24 hours can be selected.    If not set, the event is associated with the environment (&#x60;dt.entity.environment&#x60;) entity.
   * @return entitySelector
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The [entity selector](https://dt-url.net/apientityselector), defining a set of Dynatrace entities to be associated with the event.  Only entities that have been active within the last 24 hours can be selected.    If not set, the event is associated with the environment (`dt.entity.environment`) entity.")
  @JsonProperty(JSON_PROPERTY_ENTITY_SELECTOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getEntitySelector() {
    return entitySelector;
  }


  @JsonProperty(JSON_PROPERTY_ENTITY_SELECTOR)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setEntitySelector(String entitySelector) {
    this.entitySelector = entitySelector;
  }


  public EventIngest properties(Map<String, String> properties) {
    this.properties = properties;
    return this;
  }

  public EventIngest putPropertiesItem(String key, String propertiesItem) {
    if (this.properties == null) {
      this.properties = new HashMap<>();
    }
    this.properties.put(key, propertiesItem);
    return this;
  }

   /**
   * A map of event properties.  Keys with prefix &#x60;dt.*&#x60; are generally disallowed, with the exceptions of &#x60;dt.event.*&#x60;, &#x60;dt.davis.*&#x60; and &#x60;dt.entity.*&#x60;. These reserved keys may be used to set event properties with predefined semantics within the Dynatrace product. &#x60;dt.entity.*&#x60; keys may be used to provide additional information on an event, but will not lead to the event being tied to the specified entities. All other keys are interpreted as user-defined event properties.  Values of Dynatrace-reserved properties must fulfill the requirements of the respective property.
   * @return properties
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "A map of event properties.  Keys with prefix `dt.*` are generally disallowed, with the exceptions of `dt.event.*`, `dt.davis.*` and `dt.entity.*`. These reserved keys may be used to set event properties with predefined semantics within the Dynatrace product. `dt.entity.*` keys may be used to provide additional information on an event, but will not lead to the event being tied to the specified entities. All other keys are interpreted as user-defined event properties.  Values of Dynatrace-reserved properties must fulfill the requirements of the respective property.")
  @JsonProperty(JSON_PROPERTY_PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, String> getProperties() {
    return properties;
  }


  @JsonProperty(JSON_PROPERTY_PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setProperties(Map<String, String> properties) {
    this.properties = properties;
  }


  /**
   * Return true if this EventIngest object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    EventIngest eventIngest = (EventIngest) o;
    return Objects.equals(this.eventType, eventIngest.eventType) &&
        Objects.equals(this.title, eventIngest.title) &&
        Objects.equals(this.startTime, eventIngest.startTime) &&
        Objects.equals(this.endTime, eventIngest.endTime) &&
        Objects.equals(this.timeout, eventIngest.timeout) &&
        Objects.equals(this.entitySelector, eventIngest.entitySelector) &&
        Objects.equals(this.properties, eventIngest.properties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(eventType, title, startTime, endTime, timeout, entitySelector, properties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class EventIngest {\n");
    sb.append("    eventType: ").append(toIndentedString(eventType)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    startTime: ").append(toIndentedString(startTime)).append("\n");
    sb.append("    endTime: ").append(toIndentedString(endTime)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    entitySelector: ").append(toIndentedString(entitySelector)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

